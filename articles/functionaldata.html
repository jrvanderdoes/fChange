<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>functionaldata • fChange</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="functionaldata">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">fChange</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Examples.html">Examples</a></li>
    <li><a class="dropdown-item" href="../articles/functionaldata.html">functionaldata</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>functionaldata</h1>
            
      

      <div class="d-none name"><code>functionaldata.Rmd</code></div>
    </div>

    
    
<!--  output: pdf_document ; tinytex::install_tinytex()
https://stackoverflow.com/questions/7653483/github-relative-link-in-markdown-file
-->
<div class="section level2">
<h2 id="ch1">Functional Time Series Basics<a class="anchor" aria-label="anchor" href="#ch1"></a>
</h2>
<div class="section level3">
<h3 id="prepatory-information">Prepatory Information<a class="anchor" aria-label="anchor" href="#prepatory-information"></a>
</h3>
<p>The package is available on <a href="https://cran.r-project.org/web/packages/fChange/index.html" class="external-link">CRAN</a>.
Alternatively, the code can also be installed from GitHub as:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">devtools</span><span class="fu">::</span><span class="fu">install_github</span><span class="op">(</span><span class="st">"https://github.com/jrvanderdoes/fChange.git@main"</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://jrvanderdoes.github.io/fChange/">fChange</a></span><span class="op">)</span></span></code></pre></div>
<p>The data for the included exercises can be downloaded using the
following code:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">urlfile</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span></span>
<span>  <span class="st">"https://raw.githubusercontent.com/jrvanderdoes/fChange"</span>,</span>
<span>  <span class="st">"/main/vignettes/articles/german_data.csv"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">utils</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="va">urlfile</span><span class="op">)</span></span></code></pre></div>
<p>The slides can be downloaded <a href="https://raw.githubusercontent.com/jrvanderdoes/fChange/main/vignettes/articles/SSC_Short_Course.pdf" class="external-link">here</a>
and a pdf of this document can be downloaded <a href="https://raw.githubusercontent.com/jrvanderdoes/fChange/main/vignettes/articles/SSC_Short_Course_markdown.pdf" class="external-link">here</a>.</p>
</div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>In <strong><em>Time Series Analysis</em></strong>, one considers a
sequence of data observed over time. Such data can be denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">X_1,...,X_T</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
is the data observed at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
describes the number of time points at which data has been obtained,
also referred to as the “length" of the time series. An example of a
scalar, or real-valued, time series of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>504</mn></mrow><annotation encoding="application/x-tex">T=504</annotation></semantics></math>
is shown in the figure below. This depicts electricity spot prices in
Spain obtained each hour in Euro’s per Megawatt/hour during a three week
period in late spring of 2024. The ultimate goal of time series analysis
is to try and make inferences about the process that generated the data.
If we understand how a time series evolves, we can, for example,
forecast it as well as describe how much variability there might be in
future values. The time series shown in the figure below exhibits
apparent daily and weekly”seasonality" or “periodicity", which we might
expect in future data.</p>
<p><img src="functionaldata/tweeks.png" style="width:5in" alt="Hourly electricity spot price in Spain for three weeks in 2014."><!-- # ```{r, eval=FALSE} --><!-- # plot(as.vector(electricity$data)[7+1:(24*7*3)]) --><!-- # ``` --></p>
<p>Many modern time series arise from observing a nearly continuous time
process at a high frequency. Figure <a href="#Fig-spot4" reference-type="ref" reference="Fig-spot4">1.2</a> shows one year’s,
rather than three weeks, worth of hourly electricity spot prices in
Spain from the year 2024
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>T</mi><mo>=</mo><mn>8736</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T=8736)</annotation></semantics></math>.
There are evidently some patterns in the data, although they are
somewhat difficult to see given the high frequency of the data – it is
even difficult to see the expected daily and weekly periodicity in the
time series.</p>
<div class="float" id="Fig-spot4">
<img src="functionaldata/spwhole.png" style="width:5in" alt="Hourly electricity spot price in Spain during the year 2014."><div class="figcaption"><strong><em>Hourly electricity spot price in
Spain during the year 2014.</em></strong></div>
</div>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">$</span><span class="va">data</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>An alternative way to view such data is as what we will call a
“functional time series" (FTS). One might imagine here that each data
point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>
is an observation from an underlying”price process"
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>t</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{P(t), \; t\ge 0\}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is time in hours starting from January 1, 2024, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(t)</annotation></semantics></math>
is the spot price at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Since the price undergoes daily periodicity, it seems natural to segment
the price process into “daily price functions" or”daily prices curves"
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mn>24</mn><mo>+</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mn>365</mn><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">X_i(t) = P( (i-1)\times 24 + t), \quad i\in \{1,...,365\}, \quad t \in [0,24].</annotation></semantics></math></p>
<p>Of course we are not able to observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i(t)</annotation></semantics></math>
at all points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t\in [0,24]</annotation></semantics></math>.
With hourly data as in Figure <a href="#Fig-spot4" reference-type="ref" reference="Fig-spot4">1.2</a>, we observe 24 data points for each daily
function. Nonetheless, thinking of these data as being “functional" has
some benefits. For instance, we might linearly interpolate the observed
data to create full”daily price curves", and plot them sequentially as
an alternative visualization of the data (see below). Such
visualizations are shown below. There we see not only pronounced daily
seasonality, but also we observe more easily weekly periodicity as well
as some overall trends and changes in variability throughout the
year.</p>
<div class="float">
<img src="functionaldata/e1.png" style="width:5in" alt="Hourly electricity spot price in Spain during the year 2014 visualized as a functional time series."><div class="figcaption"><strong><em>Hourly electricity spot price in
Spain during the year 2014 visualized as a functional time
series.</em></strong></div>
</div>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">electricity</span><span class="op">$</span><span class="va">labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">$</span><span class="va">labels</span>, <span class="st">"%Y-%m-%d"</span><span class="op">)</span>, <span class="st">"%b"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">electricity</span>, type <span class="op">=</span> <span class="st">"fast"</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_data.png" style="width:5in" alt="Another angle of hourly electricity spot price in Spain during the year 2014 visualized as a functional time series."><div class="figcaption"><strong><em>Another angle of hourly electricity
spot price in Spain during the year 2014 visualized as a functional time
series.</em></strong></div>
</div>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">electricity</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="fl">0.6</span>, z <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Such functional time series arise in many different settings. Figure
<a href="#Fig-sp" reference-type="ref" reference="Fig-sp">1.5</a> shows
a functional time series constructed from one minute resolution intraday
prices of an S&amp;P500 Exchange Traded Fund and linear interpolation
from the years 2019 to 2023
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≈</mo><mn>1250</mn></mrow><annotation encoding="application/x-tex">T\approx1250</annotation></semantics></math>).
Here each curve is constructed from 390 observations and linear
interpolation. Other examples include pollution in a city (Figure <a href="#fig:pollution" reference-type="ref" reference="fig:pollution">1.6</a>) and (log) mortality rates as a
function of age in France (Figure <a href="#fig:fmortality" reference-type="ref" reference="fig:fmortality">1.7</a>).</p>
<div class="float" id="Fig-sp">
<img src="functionaldata/yield.png" style="width:5in" alt="An FTS constructed from one minute resolution intraday prices from the S&amp;P 500."><div class="figcaption"><strong><em>An FTS constructed from one minute
resolution intraday prices from the S&amp;P 500.</em></strong></div>
</div>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">SPYUS500</span><span class="op">)</span></span></code></pre></div>
<div class="float" id="fig:pollution">
<img src="functionaldata/pollution1.png" style="width:5in" alt="Levels of particulate matter pollution in parts per million measured every 30 minutes in a Graz, Austria, visualized as a functional time series."><div class="figcaption"><strong><em>Levels of particulate matter
pollution in parts per million measured every 30 minutes in a Graz,
Austria, visualized as a functional time series.</em></strong></div>
</div>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">urlfile1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span></span>
<span>  <span class="st">"https://raw.githubusercontent.com/jrvanderdoes/fChange"</span>,</span>
<span>  <span class="st">"/main/vignettes/articles/pollution.txt"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">city</span> <span class="op">&lt;-</span> <span class="fu">utils</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span><span class="va">urlfile1</span>, header <span class="op">=</span> <span class="cn">TRUE</span>, sep <span class="op">=</span> <span class="st">","</span><span class="op">)</span><span class="op">$</span><span class="va">x</span></span>
<span></span>
<span><span class="va">city_dfts</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/dfts.html">dfts</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="va">city</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">48</span><span class="op">)</span>,</span>
<span>  labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"Day"</span>, <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">city</span><span class="op">)</span> <span class="op">/</span> <span class="fl">48</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  season <span class="op">=</span> <span class="fl">7</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span></span></code></pre></div>
<p>The benefits of the “functional" perspective are not just limited to
visualization. The models and inferential procedures that come about
from thinking of such data as functional data objects are often unique,
flexible, and respect the”continuous" nature of the process that
generated the data. Moreover, for many data of this type we are
interested in inferring, or producing predictions that are compatible
with, the function properties of the process that generated the data
such as “continuity" or”smoothness". These natural concepts are unique
to functions and are not easily handled solely within a multivariate
framework.</p>
<p>The goal of this short course is to introduce functional time series,
and discuss some tools for analyzing them in <code>R</code>.</p>
<div class="float" id="fig:fmortality">
<img src="functionaldata/french_rates.png" style="width:5in" alt="Log mortality rates for French males across ages 0 to 100 over viewed as a functional time series over the years 1816 to 2022."><div class="figcaption"><strong><em>Log mortality rates for French males
across ages 0 to 100 over viewed as a functional time series over the
years 1816 to 2022.</em></strong></div>
</div>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">urlfile2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span></span>
<span>  <span class="st">"https://raw.githubusercontent.com/jrvanderdoes/fChange"</span>,</span>
<span>  <span class="st">"/main/vignettes/articles/log_fmort.rds"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">fmort</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/connections.html" class="external-link">url</a></span><span class="op">(</span><span class="va">urlfile2</span>, <span class="st">"rb"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fmort</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">4.75</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">2.5</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">2.75</span>, y <span class="op">=</span> <span class="fl">2</span>, z <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="function-spaces-and-l201">Function Spaces and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#function-spaces-and-l201"></a>
</h3>
<p>From a theoretical perspective we think of a time series as being a
realization of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
from a discretely indexed <em>stochastic process</em>. In other words,
when we observe a real valued time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">X_1,...,X_T</annotation></semantics></math>,
we assume that it came from observing a partial stretch of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
from a stochastic process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mi>ℤ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{X_i, \; i\in \mathbb{Z}\}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">X_i \in \mathbb{R}</annotation></semantics></math>.
<em>Multivariate</em> or <em>vector valued</em> time series are of the
form <span class="math inline">${\bf X}_1,...,{\bf X}_T$</span> where
<span class="math inline">${\bf X}_i \in \mathbb{R}^d$</span>, and may
be similarly viewed as arising from observing a stochastic process <span class="math inline">$\{{\bf X}_i \in \mathbb{R}^d, \; i\in
\mathbb{Z}\}$</span>.<br>
When we think of data as being “functional" in nature, we think of them
as taking their values in some space of functions rather than in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℝ</mi><mi>d</mi></msup><annotation encoding="application/x-tex">\mathbb{R}^d</annotation></semantics></math>.
When functional data are defined over a compact interval, for instance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,24]</annotation></semantics></math>
as in the electricity spot price curve example, it is natural to view
them as functions
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">X_i : [0,24] \mapsto \mathbb{R}.</annotation></semantics></math>
For functions defined over a compact interval it makes sense for the
sake of simplicity to assume, by applying a linear transformation to the
input, that the function is defined over the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>.</p>
<p>What are reasonable classes of functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">X_i:[0,1] \mapsto \mathbb{R}</annotation></semantics></math>
might take its value in? Some “famous" spaces of functions are the space
of continuous functions
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>f</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is continuous</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">C[0,1] = \{ f:[0,1] \mapsto \mathbb{R}, \; f \mbox{ is continuous}\},</annotation></semantics></math>
or the space of square integrable functions
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi><mo>,</mo><mspace width="0.278em"></mspace><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mi>f</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>x</mi><mo>&lt;</mo><mi>∞</mi><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">L^2[0,1] = \left\{ f:[0,1] \mapsto \mathbb{R}, \;  \int_0^1 f^2(x)dx &lt; \infty \right\}.</annotation></semantics></math>
Another important example is”Sobolev Space", which takes into
consideration the derivatives of the function. An example of a Sobolev
space involving the first derivative is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi><mo>,</mo><mspace width="0.278em"></mspace><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mi>f</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>f</mi><mi>′</mi><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>x</mi><mo>&lt;</mo><mi>∞</mi><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">W^{1,2} = \left\{   f:[0,1] \mapsto \mathbb{R}, \; \int_0^1 f^2(x)dx + \int_0^1 [f']^2(x)dx &lt; \infty \right\}.</annotation></semantics></math>
It is worth noting that each of these spaces are “infinite dimensional",
and so viewing data as residing in these spaces is a significant
departure from the finite dimensional setting of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℝ</mi><mi>d</mi></msup><annotation encoding="application/x-tex">\mathbb{R}^d</annotation></semantics></math>.</p>
<p><em>Definition</em>: For a given function space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math>,
e.g. any of the above three examples, a <em>functional time series</em>
(FTS)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">X_1,...,X_T</annotation></semantics></math>
is an observed stretch of data of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
of a function-valued stochastic process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><mi>ℋ</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mi>ℤ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{X_i \in \mathcal{H}, \; i\in \mathbb{Z}\}</annotation></semantics></math>.</p>
<p>The choice of space that we view the data as residing in is
consequential in that it suggests how we might measure distance between
functions. The canonical distance measure, or norm, on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">C[0,1]</annotation></semantics></math>
is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mi>f</mi><mo>−</mo><mi>g</mi><msub><mo stretchy="false" form="postfix">∥</mo><mi>∞</mi></msub><mo>=</mo><munder><mo>sup</mo><mrow><mi>x</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow></munder><mrow><mo stretchy="true" form="prefix">|</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">|</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\| f-g \|_\infty = \sup_{x\in [0,1]} |f(x) - g(x)|.</annotation></semantics></math>
On
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>,
we usually measure distance using
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mi>f</mi><mo>−</mo><mi>g</mi><msub><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">\| f-g \|_2 = \left( \int_{0}^{1} [f(x) - g(x) ]^2 dx \right)^{1/2}.</annotation></semantics></math></p>
<p>What ends up being a critical distinction between these two spaces
and their canonical distance measures is that the space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
with distance measure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\|\cdot \|_2</annotation></semantics></math>
is a <em>separable Hilbert Space</em>, whereas the space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">C[0,1]</annotation></semantics></math>
with distance measure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mi>∞</mi></msub></mrow><annotation encoding="application/x-tex">\|\cdot\|_\infty</annotation></semantics></math>
(or even with distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\|\cdot\|_2</annotation></semantics></math>)
is not a separable Hilbert space. In addition to the mathematical
properties of linearity and completeness, Hilbert spaces also have the
nice property that their distance measure is generated by an <em>inner
product</em>. The canonical inner product on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\langle f,g \rangle = \int_{0}^{1}f(t)g(t)dt.</annotation></semantics></math>
Evidently
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mi>f</mi><msubsup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn><mn>2</mn></msubsup><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\|f\|_2^2 = \langle f,f\rangle</annotation></semantics></math>.
The existence of an inner product means that the space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
has a similar “geometry" to a finite dimensional space
<strong>—</strong> the inner product defines angles between functions
and further the notion of”orthogonality".</p>
<p><em>Separability</em> in this setting is equivalent to the existence
of a <em>complete orthonormal system</em> (CONS) of basis functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\phi_i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i\in \{1,2,...\}</annotation></semantics></math>
satisfying the properties 1)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo>,</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><mn>1</mn><mo stretchy="false" form="prefix">{</mo><mi>i</mi><mo>=</mo><mi>j</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\langle \phi_i, \phi_j \rangle = {1}\{i=j\}</annotation></semantics></math>,
i.e. the functions are orthogonal and have norm one, and 2) for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">f\in L^2[0,1]</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">∞</mo></munderover><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    f(t) =  \sum_{j=1}^{\infty} \langle f , \phi_j \rangle \phi_j(t).
\end{aligned}</annotation></semantics></math></p>
<p>Here equality is understood in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo>−</mo></mrow><annotation encoding="application/x-tex">L^2-</annotation></semantics></math>sense,
which means that the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\|\cdot\|_2</annotation></semantics></math>
norm of the difference between the left and right hand sides of the
above is zero.</p>
<p>The equation on CONS, in addition to the geometry introduced by the
inner product, means that the space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
is “close" in a sense to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℝ</mi><mi>d</mi></msup><annotation encoding="application/x-tex">\mathbb{R}^d</annotation></semantics></math>.
If for instance we were ever able to make the simplification
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">∞</mo></munderover><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo><msub><mi>ϕ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    f(t) =  \sum_{j=1}^{\infty} \langle f , \phi_j \rangle \phi_j(t) \approx \sum_{j=1}^{d} \langle f , \phi_j \rangle \phi_j(t),
\end{aligned}</annotation></semantics></math> the right hand side of the
above is characterized by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mi>ϕ</mi><mi>d</mi></msub><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mi>⊤</mi></msup><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">( \langle f , \phi_1 \rangle,..., \langle f , \phi_d \rangle )^\top \in \mathbb{R}^d</annotation></semantics></math>,
and we would be in more familiar territory. This line of reasoning
suggests that an important step in functional data and FTS analysis is
performing effective dimension reduction.</p>
<p>Throughout these notes we generally consider FTS that we think of as
taking value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>.
We conclude this section with a couple of remarks.</p>
<p><em>Remark</em>: An important result of analysis is that <em>all</em>
infinite dimensional, separable Hilbert spaces are “isometrically
isomorphic". This means that for any separable Hilbert spaces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℋ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\mathcal{H}_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℋ</mi><mi>B</mi></msub><annotation encoding="application/x-tex">\mathcal{H}_B</annotation></semantics></math>
with respective norms
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">\|\cdot\|_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mo>⋅</mo><msub><mo stretchy="false" form="postfix">∥</mo><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\|\cdot\|_B</annotation></semantics></math>,
there exists a bijection
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>:</mo><msub><mi>ℋ</mi><mi>A</mi></msub><mo>↦</mo><msub><mi>H</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">z: \mathcal{H}_A \mapsto H_B</annotation></semantics></math>
so that for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>∈</mo><msub><mi>ℋ</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">f,g \in \mathcal{H}_A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">∥</mo><mi>f</mi><mo>−</mo><mi>g</mi><msub><mo stretchy="false" form="postfix">∥</mo><mi>A</mi></msub><mo>=</mo><mo stretchy="false" form="postfix">∥</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>z</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mo stretchy="false" form="postfix">∥</mo><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\|f-g\|_A = \|z(f) - z(g)\|_B</annotation></semantics></math>.
As a result all separable Hilbert spaces are in a sense equivalent to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math><strong>—</strong> any data residing in another separable Hilbert space
can be mapped to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
in such a way that distances remain the same. Many important spaces in
applications, for example the Sobolev space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>W</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msup><annotation encoding="application/x-tex">W^{1,2}</annotation></semantics></math>
mentioned above, may be fashioned into separable Hilbert spaces, and so
in a sense considering methods to analyze data in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>
has broad implications for analyzing many types of functional data.</p>
<p><em>Remark</em>: Analyzing FTS when we think of the data as being
elements of a more general Banach space,
e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">C[0,1]</annotation></semantics></math>,
poses some significant challenges from a theoretical perspective. Many
problems remain open in this area.</p>
</div>
<div class="section level3">
<h3 id="sec-pre">Preprocessing FTS<a class="anchor" aria-label="anchor" href="#sec-pre"></a>
</h3>
<p>In most cases in which FTS analysis is applied (but not all!), the
observed data are discrete measurements of an underlying process that is
indexed by a continuous domain. For example, the spot price electricity
data previously visualized we can view as being indexed on the
continuous interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,24]</annotation></semantics></math>,
although with hourly data we only observe each daily function on the
points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mn>24</mn><mo stretchy="false" form="postfix">}</mo><mo>⊂</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>24</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\{0,....,24\} \subset[0,24]</annotation></semantics></math>.
The first step in FTS is often to complete these data to full curves
using “interpolation" or”smoothing" techniques. Good resources for this
material are <span class="citation">(J. Ramsay, Hooker, and Graves
2009)</span> and <span class="citation">(J. O. Ramsay and Silverman
2005)</span>.</p>
<p>Such raw data can often be represented as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mn>0</mn><mo>≤</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><mi>⋯</mi><mo>&lt;</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><msub><mi>n</mi><mi>i</mi></msub></mrow></msub><mo>≤</mo><mn>1</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">X_i(t_{i,j}), \;\; i \in \{1,...,T\}, \; \; j \in \{1,...,n_i\}, \;\;  0 \le t_{i,1} &lt; \cdots  &lt; t_{i,n_i} \le 1.</annotation></semantics></math></p>
<p>One very simple way to complete such data to a full curve is using
<em>linear interpolation</em>. We simply define a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>↦</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\hat{X}_i: [0,1] \mapsto \mathbb{R}</annotation></semantics></math>
so that for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mi>t</mi><mo>≤</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_{i,j} \le t \le t_{i,j+1}</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac><mrow><mo stretchy="true" form="prefix">[</mo><mi>t</mi><mo>−</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat{X}_i(t) = \frac{X_i(t_{i,j+1})-X_i(t_{i,j})}{t_{i,j+1} - t_{i,j} }[t -t_{i,j}] +  X_i(t_{i,j}).</annotation></semantics></math>
Evidently the linearly interpolated curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{X}_i(t_{i,j})</annotation></semantics></math>
will agree with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i(t_{i,j})</annotation></semantics></math>
at each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">t_{i,j}</annotation></semantics></math>.
This is an effective approach when the raw data are thought to be
observed without measurement error from an approximately continuous
underlying process, and are “dense" in the sense that the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
is large and the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mi>′</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">t_{i,j}'s</annotation></semantics></math>
are distributed approximately uniformly in the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>.</p>
<p>When we view the underlying curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
as a function in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>,
another natural approach to complete such data to a full curve is to
take advantage of CONS and construct for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t\in [0,1]</annotation></semantics></math><span class="math display">$$\begin{aligned}
    \hat{X}_i(t)  = \sum_{j=1}^{K} c_i \phi_j(t) = {\bf c}^\top {\bf
\Phi}(t),
\end{aligned}$$</span> where the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\phi_j</annotation></semantics></math>
is a CONS,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
is a user-specified parameter, <span class="math inline">${\bf c} =
(c_1,....,c_K)^\top$</span> and <span class="math inline">${\bf \Phi}(t)
= (\phi_1(t),...,\phi_K(t))^\top$</span>. The user in this typically
specifies the basis functions along with the integer
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>,
and then the vector of coefficients <span class="math inline">${\bf
c}$</span> is chosen using some optimization procedure. Two popular
choices for the basis functions are the <em>standard Fourier basis</em>,
which are functions of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mn>2</mn></msqrt><mo>cos</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mi>j</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msqrt><mn>2</mn></msqrt><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mi>j</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\phi_j(t) = \sqrt{2}  \cos (2 \pi j t) + \sqrt{2} \sin (2 \pi j t),</annotation></semantics></math>
and the bases of <em>orthogonal B-spline polynomials</em>. A plot of
cubic B-spline polynomials based on equally spaced knots is shown in the
figure below.</p>
<p><img src="functionaldata/spline.png" style="width:5in" alt="A plot of cubic B-spline polynomials based on equally spaced knots."><!-- # ```{r, eval=FALSE} --><!-- # plot(fda::create.bspline.basis(nbasis = 10)) --><!-- # ``` --></p>
<p>While a detailed explanation of spline interpolation/smoothing is
beyond the scope of this short course, we mention that this method came
about as a way to smooth or interpolate raw data in such a way that the
resulting curve maintains certain differentiability properties.</p>
<p>One often considers the nature of the data and the goals of
subsequent analysis when choosing a basis. For data that his highly
periodic it might make sense to smooth/interpolate it using a Fourier
basis, while a spline basis might be more appropriate for less
structured data that we think may have been drawn from an underlying
continuous or differentiable function. Given the flexibility (pun
intended) of cubic-spline smoothing, it is often used as a default.</p>
<p><img src="functionaldata/splex.png" id="Fig-spl" style="width:5in" alt="Example of a functional data object created using penalized cubic splines."><!-- # ```{r, eval=FALSE} --><!-- # plot(fda::create.bspline.basis(nbasis = 10)) --><!-- # ``` --></p>
<p>After choosing a basis, we still must select
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
and the coefficient vector <span class="math inline">${\bf c}$</span> in
the equation. This is typically done using least squares: we choose
<span class="math inline">${\bf c}$</span> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
to minimize <span class="math display">$$\mbox{SSE}_{i,K}({\bf c}) =
\sum_{j=1}^{n_i}[X_i(t_{i,j}) - {\bf c}^\top{\bf
\Phi}(t_{i,j})]^2.$$</span> Here if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>≥</mo><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K \ge n_i</annotation></semantics></math>,
the sum of squared errors can be minimized at <span class="math inline">$SSE_{i,K}({\bf c})=0$</span>, so that the data are
“interpolated", i.e. the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{X}_i</annotation></semantics></math>
attains the same values as the observed data at the points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">t_{i,j}</annotation></semantics></math>.
This is sometimes desirable, for example if the raw functional data is
thought to be observed without additional observational error. In some
cases though this leads to evident”overfitting". In these cases it can
make sense to additionally penalize the “complexity" or”roughness" of
the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{X}_i</annotation></semantics></math>.
Although this can be done in many ways, a natural choice is to measure
the roughness of the function using a “second derivative penalty" <span class="math display">$$\mbox{PEN}_{i,K}({\bf c}) = \int_{0}^{1} \left[
\frac{d^2}{dt^2} {\bf c}^\top {\bf \Phi}(t) \right]^2 dt,$$</span> and
then choose <span class="math inline">${\bf c}$</span> to minimize <span class="math display">$$\mbox{SSE}_{i,K}({\bf c}) + \lambda
\mbox{PEN}_{i,K}({\bf c}),$$</span> for a tuning parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda &gt;0</annotation></semantics></math>.
Large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
forces the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{X}_i</annotation></semantics></math>
to be less rough, whereas small
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
leads to a function that more closely interpolates the data. Often
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
is selected using leave-one-out cross-validation, or using the”eye-ball
test"<strong>—</strong> we try several
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
until the resulting curve “looks good".</p>
<p>Using either of these methods, we can complete the raw data to full
curves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{X}_i(t)</annotation></semantics></math>
which we can relabel back to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i(t)</annotation></semantics></math>.
Often practically once we have created such curves we will re-valuate
them at some, often dense, grid of equally spaced points for subsequent
analyses and storage as an array.</p>
<p>Suppose that the Spanish electricity data was collected between 20
and 40 times a day, at potentially different points of time. Such data
could be fit using a B-spline basis and evaluated such that each curve
is evaluated at the same time each day. Different values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
can result in drastically different discrete evaluations; see Figures
below. In practice, organizing data such that each day is observed at
the same time points is computationally valuable.</p>
<div class="float" id="Fig-elam1">
<img src="functionaldata/electricity_lam1.png" style="width:5in" alt="Unevenly observed electricity prices fit to B-spline basis functions and evaluated at 24 daily observation for smoothing parameter \lambda=1."><div class="figcaption"><strong><em>Unevenly observed electricity prices
fit to B-spline basis functions and evaluated at 24 daily observation
for smoothing parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda=1</annotation></semantics></math>.</em></strong></div>
</div>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">urlfile3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span></span>
<span>  <span class="st">"https://raw.githubusercontent.com/jrvanderdoes/fChange"</span>,</span>
<span>  <span class="st">"/main/vignettes/articles/uneven_spanish.rds"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">uneven_spanish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/connections.html" class="external-link">url</a></span><span class="op">(</span><span class="va">urlfile3</span>, <span class="st">"rb"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">eval_pts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">24</span><span class="op">)</span></span>
<span><span class="va">elec_eval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="fl">24</span>, ncol <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">long_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">long_data</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span></span>
<span>      <span class="va">long_data</span>,</span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>        <span class="st">"x"</span> <span class="op">=</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span></span>
<span>          <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span><span class="op">)</span>,</span>
<span>        <span class="st">"y"</span> <span class="op">=</span> <span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span></span>
<span>      <span class="op">)</span></span>
<span>    <span class="op">)</span></span>
<span></span>
<span>  <span class="va">fda_fit</span> <span class="op">&lt;-</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/Data2fd.html" class="external-link">Data2fd</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">pts</span>, <span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span>,</span>
<span>    basisobj <span class="op">=</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/create.bspline.basis.html" class="external-link">create.bspline.basis</a></span><span class="op">(</span>nbasis <span class="op">=</span> <span class="fl">24</span><span class="op">)</span>,</span>
<span>    lambda <span class="op">=</span> <span class="fl">1</span></span>
<span>  <span class="op">)</span> <span class="co"># ,</span></span>
<span>  <span class="co"># lambda = .0001)</span></span>
<span>  <span class="va">elec_eval</span><span class="op">[</span>, <span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/eval.fd.html" class="external-link">eval.fd</a></span><span class="op">(</span><span class="va">eval_pts</span>, <span class="va">fda_fit</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">elec_eval</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.Date.html" class="external-link">seq.Date</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2014-01-01"</span><span class="op">)</span>, to <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2014-12-31"</span><span class="op">)</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># electricity$labels</span></span>
<span></span>
<span><span class="va">spanish_electricity</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/dfts.html">dfts</a></span><span class="op">(</span><span class="va">elec_eval</span>,</span>
<span>    labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">elec_eval</span><span class="op">)</span>, <span class="st">"%Y-%m-%d"</span><span class="op">)</span>, <span class="st">"%b"</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">spanish_electricity</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">0.8</span>, y <span class="op">=</span> <span class="fl">0.6</span>, z <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="float" id="Fig-elam2">
<img src="functionaldata/electricity_lam0001.png" style="width:5in" alt="Unevenly observed electricity prices fit to B-spline basis functions and evaluated at 24 daily observation for smoothing parameters \lambda=0.0001."><div class="figcaption"><strong><em>Unevenly observed electricity prices
fit to B-spline basis functions and evaluated at 24 daily observation
for smoothing parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0.0001</mn></mrow><annotation encoding="application/x-tex">\lambda=0.0001</annotation></semantics></math>.</em></strong></div>
</div>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">urlfile3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span></span>
<span>  <span class="st">"https://raw.githubusercontent.com/jrvanderdoes/fChange"</span>,</span>
<span>  <span class="st">"/main/vignettes/articles/uneven_spanish.rds"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">uneven_spanish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/connections.html" class="external-link">url</a></span><span class="op">(</span><span class="va">urlfile3</span>, <span class="st">"rb"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">eval_pts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">24</span><span class="op">)</span></span>
<span><span class="va">elec_eval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="fl">24</span>, ncol <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">long_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">long_data</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span></span>
<span>      <span class="va">long_data</span>,</span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>        <span class="st">"x"</span> <span class="op">=</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span></span>
<span>          <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span><span class="op">)</span>,</span>
<span>        <span class="st">"y"</span> <span class="op">=</span> <span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span></span>
<span>      <span class="op">)</span></span>
<span>    <span class="op">)</span></span>
<span></span>
<span>  <span class="va">fda_fit</span> <span class="op">&lt;-</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/Data2fd.html" class="external-link">Data2fd</a></span><span class="op">(</span><span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">pts</span>, <span class="va">uneven_spanish</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">values</span>,</span>
<span>    basisobj <span class="op">=</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/create.bspline.basis.html" class="external-link">create.bspline.basis</a></span><span class="op">(</span>nbasis <span class="op">=</span> <span class="fl">24</span><span class="op">)</span>,</span>
<span>    lambda <span class="op">=</span> <span class="fl">0.0001</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">elec_eval</span><span class="op">[</span>, <span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">fda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/fda/man/eval.fd.html" class="external-link">eval.fd</a></span><span class="op">(</span><span class="va">eval_pts</span>, <span class="va">fda_fit</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">elec_eval</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.Date.html" class="external-link">seq.Date</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2014-01-01"</span><span class="op">)</span>, to <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2014-12-31"</span><span class="op">)</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># electricity$labels</span></span>
<span></span>
<span><span class="va">spanish_electricity</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/dfts.html">dfts</a></span><span class="op">(</span><span class="va">elec_eval</span>,</span>
<span>    labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">elec_eval</span><span class="op">)</span>, <span class="st">"%Y-%m-%d"</span><span class="op">)</span>, <span class="st">"%b"</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">spanish_electricity</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">0.8</span>, y <span class="op">=</span> <span class="fl">0.6</span>, z <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="visualizing-fts">Visualizing FTS<a class="anchor" aria-label="anchor" href="#visualizing-fts"></a>
</h3>
<p>After potentially pre-processing the data, it is often useful to plot
the FTS
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="0.278em"></mspace><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{X_i(t), \; i \in \{1,...,T\}, \; t\in [0,1]\}</annotation></semantics></math>
to inspect for trends and gauge the overall behavior of the series. One
way to do this is with what is called a <em>rainbow spaghetti plot</em>.
In such a plot, curves are rendered in three dimensions, with one axis
denoting “discrete time"
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i \in \{1,...,T\}</annotation></semantics></math>,
one axis measuring the”functional parameter"
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t\in [0,1]</annotation></semantics></math>,
and the vertical axis measuring the real value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i(t)</annotation></semantics></math>.
Curves are initially plotted in red, and then progress through the
rainbow color spectrum to violet for the final curves.</p>
<p>The functional plots included to this point have been rainbow
spaghetti plots, and are interactive in <code>R</code>. However, there
are many possible visualizations for functional data. Two other
visualizations of the (log) French mortality rates are shown in below.
The first is not interactive and runs much faster. Hence, it is
well-employed for larger FTS. The second is called a rainbow plot and
stacks the observations to highlight major shifts.</p>
<div class="float">
<img src="functionaldata/fmortality_fast.png" style="width:5in" alt="Fast rainbow spaghetti plot of the FTS French mortality data."><div class="figcaption"><strong><em>Fast rainbow spaghetti plot of the
FTS French mortality data.</em></strong></div>
</div>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fmort</span>, type <span class="op">=</span> <span class="st">"fast"</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/fmortality_rainbow.png" style="width:5in" alt="Rainbow plot of the FTS French mortality data."><div class="figcaption"><strong><em>Rainbow plot of the FTS French
mortality data.</em></strong></div>
</div>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fmort</span>, type <span class="op">=</span> <span class="st">"rainbow"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="mean-covariance-and-principal-component-analysis">Mean, covariance, and principal component analysis<a class="anchor" aria-label="anchor" href="#mean-covariance-and-principal-component-analysis"></a>
</h3>
<p>When beginning to analyze an FTS, we often consider computing some
summary values and performing dimension reduction. Many of these tasks
are carried out by thinking of the FTS as being <em>stationary.</em></p>
<p><em>Definition</em>: An FTS
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mo>∈</mo><mi>ℋ</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mi>ℤ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{X_i \in \mathcal{H}, \; i \in \mathbb{Z}\}</annotation></semantics></math>
is (strictly) stationary if for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">p\in \mathbb{N}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>i</mi><mi>p</mi></msub><mo>,</mo><mi>h</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">i_1,...,i_p,h \in \mathbb{Z}</annotation></semantics></math>,
and all (Borel) subsets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>B</mi><mi>p</mi></msub><mo>⊂</mo><mi>ℋ</mi></mrow><annotation encoding="application/x-tex">B_1,...,B_p \subset \mathcal{H}</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>∈</mo><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><msub><mi>i</mi><mi>p</mi></msub></msub><mo>∈</mo><msub><mi>B</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><mi>h</mi></mrow></msub><mo>∈</mo><msub><mi>B</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mrow><msub><mi>i</mi><mi>p</mi></msub><mo>+</mo><mi>h</mi></mrow></msub><mo>∈</mo><msub><mi>B</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">P(X_{i_1} \in B_1,..., X_{i_p} \in B_p ) = P(X_{i_1+h} \in B_1,..., X_{i_p+h} \in B_p ).</annotation></semantics></math></p>
<p>Roughly speaking a time series is stationary if its stochastic
properties are the same no matter where we look at the series. This
would imply for example that each curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
has the same distribution, and further that each pair of curves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>,</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X_i,X_{i+h})</annotation></semantics></math>
have the same joint distribution for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Of course with most real time series this assumption is clearly invalid,
and we discuss statistical tests of this assumption in Chapter <a href="#ch3" reference-type="ref" reference="ch3">3</a>, however the
resulting summaries and dimension reduction methods are often still
useful even when analyzing non-stationary time series.</p>
<p>For a stationary FTS
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
the <em>mean function</em> of the series is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">E[X_i(t)] = \mu(t).</annotation></semantics></math>
We typically estimate the mean function using the sample mean function
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\bar{X}_T(t) = \frac{1}{T} \sum_{i=1}^T X_i(t).</annotation></semantics></math></p>
<p>The <em>covariance operator</em> of a stationary FTS is defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">⟩</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mi>x</mi><mo>∈</mo><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">C(x)(t) := E [\langle X_i-\mu, x\rangle (X_i-\mu)(t) ],\ \ \ x \in L^2[0,1],</annotation></semantics></math>
and is well defined so long as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false" form="postfix">∥</mo><msub><mi>X</mi><mi>i</mi></msub><msubsup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn><mn>2</mn></msubsup><mo>&lt;</mo><mi>∞</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">E\|X_i\|_2^2 &lt; \infty.</annotation></semantics></math>
The covariance operator is also characterized by the <em>covariance
kernel</em>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>μ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">c(t,s) = E[ (X_i(t) - \mu(t) ) (X_i(s) - \mu_i(s))],</annotation></semantics></math>
via the relation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>s</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">C(x)(t) = \int_0^1 c(t,s)x(s) ds.</annotation></semantics></math>
In a sense the covariance kernel takes the place of the “covariance
matrix", and the covariance operator is akin to using such a matrix to
define a linear operator on the space.</p>
<p>These quantities are most commonly estimated using the empirical
covariance kernel
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>c</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\widehat{c}(t,s) = \frac{1}{T} \sum_{i=1}^T [X_i(t) - \bar{X}_T(t)][X_i(s) - \bar{X}_T(s) ],</annotation></semantics></math>
and the empirical covariance operator
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>C</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mover><mi>c</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>s</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\widehat{C}(x)(t) = \int_0^1 \hat{c}(t,s)x(s) ds.</annotation></semantics></math>
The eigenfunctions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>,
denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">v_j, j \ge 1</annotation></semantics></math>,
are often called the <em>functional principal components</em> (FPCs),
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>λ</mi><mi>j</mi></msub><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C(v_j) = \lambda_j v_j</annotation></semantics></math>.
These functions are orthogonal and define a CONS of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L^2[0,1]</annotation></semantics></math>.
As such they may be used to decompose the FTS as in the CONS equation.
This turns out to be a somewhat special expansion for a stationary FTS
called the <em>Karhunen<strong>–</strong>Loéve (KL) expansion</em>. It
takes the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">∞</mo></munderover><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>v</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo>,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
    X_i(t) = \mu(t) + \sum_{j=1}^\infty \xi_{ij} v_j(t), \ \ \
    \xi_{ij} = \langle X_i - \mu, v_j \rangle.</annotation></semantics></math>
The <em>scores</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\xi_{ij}</annotation></semantics></math>
satisfy
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E\xi_{ij} = 0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msubsup><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>=</mo><msub><mi>λ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">E\xi_{ij}^2 = \lambda_j</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>ξ</mi><mrow><mi>i</mi><msup><mi>j</mi><mi>′</mi></msup></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E[\xi_{ij}\xi_{ij^\prime}] = 0</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>≠</mo><msup><mi>j</mi><mi>′</mi></msup></mrow><annotation encoding="application/x-tex">j\neq j^\prime</annotation></semantics></math>.</p>
<p>This KL expansion is “optimal" in the following sense: if we consider
the truncated expansion
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><msub><mi>ξ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>v</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    X_i^{(d)}(t) =  \mu(t) + \sum_{j=1}^d \xi_{ij} v_j(t)
\end{aligned}</annotation></semantics></math> for any positive integer
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>,
this”finite dimensional" representation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
is optimal in that it minimizes the mean squared-normed error
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false" form="postfix">∥</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><msubsup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">E\| X_i - X_i^{(d)}\|^2_2</annotation></semantics></math>
among all possible choices of the functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>v</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">v_1,...,v_d</annotation></semantics></math>
in the equation.</p>
<p>Expansion is not directly accessible because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
and the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>j</mi></msub><annotation encoding="application/x-tex">v_j</annotation></semantics></math>
are unknown population parameters, but can be replaced with their
empirical counterparts. In particular the FPCs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>j</mi></msub><annotation encoding="application/x-tex">v_j</annotation></semantics></math>
and the eigenvalues
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\lambda_j</annotation></semantics></math>
are estimated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><annotation encoding="application/x-tex">\hat v_j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><annotation encoding="application/x-tex">\hat\lambda_j</annotation></semantics></math>
defined as the solutions to the equations
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>C</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
    \widehat{C}(\hat v_j)(t) =  \hat \lambda_j \hat v_j(t),  \ \ 
    j \in \{1,...,T\}.</annotation></semantics></math></p>
<p>Each curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
can then be approximated by a linear combination of a finite set of the
estimated FPCs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><annotation encoding="application/x-tex">\hat v_j</annotation></semantics></math>,
i.e. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    X_i(t) \approx \bar{X}_T + \sum_{j=1}^{d} \hat{\xi}_{ij} \hat v_j(t),
\end{aligned}</annotation></semantics></math> where the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mo>,</mo><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\hat{\xi}_{ij}=\langle X_i-\bar{X}_T, {\hat v}_j \rangle</annotation></semantics></math>
are the sample scores. Each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\xi}_{ij}</annotation></semantics></math>
quantifies the contribution of the curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><annotation encoding="application/x-tex">{\hat v}_j</annotation></semantics></math>
to the shape of the curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>.
Thus, the vector of the sample scores,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>,</mo><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>p</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>⊤</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">[\hat{\xi}_{i1}, \hat{\xi}_{i2}, \ldots, \hat{\xi}_{ip}]^{\top},</annotation></semantics></math>
encodes the shape of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
to a good approximation.</p>
<p>When using this dimension reduction we must select
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>.
This is most commonly done using the <em>Total Variation Explained
(TVE)</em> approach: we choose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
so that the percentage
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">TVE</mtext><mi>d</mi></msub><mo>=</mo><mfrac><mrow><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mi>d</mi></msub></mrow><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mover><mi>c</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mi>d</mi></msub></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">∞</mo></munderover><msub><mover><mi>λ</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mbox{TVE}_d = \frac{\hat{\lambda}_1+ \cdots + \hat{\lambda}_d}{ \int_0^1 \widehat{c}(t,t)dt} =  \frac{\hat{\lambda}_1+ \cdots + \hat{\lambda}_d}{ \sum_{i=1}^\infty \hat{\lambda}_i}</annotation></semantics></math>
is sufficiently large. For example a common criterion is to choose
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mo>inf</mo><mrow><mo stretchy="true" form="prefix">{</mo><mi>p</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mtext mathvariant="normal">TVE</mtext><mi>p</mi></msub><mo>≥</mo><mn>0.95</mn><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">d = \inf \left\{ p \; :\mbox{TVE}_p \ge 0.95 \right\}.</annotation></semantics></math>
In many examples this leads to a reasonably small value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>.
Tuning the threshold for selecting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
and analyzing the effects this has on any conclusion drawn from the data
is almost always something worth considering.</p>
<div class="float" id="fig:fmortality_skree">
<img src="functionaldata/fmortality_skree.png" style="width:5in" alt="Scree plot for PCA with the FTS French mortality data."><div class="figcaption">Scree plot for PCA with the FTS French mortality
data.</div>
</div>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># May want to review the comment figure</span></span>
<span><span class="co"># plot(fmort, type='rainbow')</span></span>
<span></span>
<span><span class="va">pca_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pca.html">pca</a></span><span class="op">(</span><span class="va">fmort</span>, TVE <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pca_data</span><span class="op">$</span><span class="va">center</span><span class="op">)</span></span>
<span><span class="va">pca_data</span><span class="op">$</span><span class="va">skree</span><span class="op">$</span><span class="va">comb_skree</span></span></code></pre></div>
<p>We again return the French mortality data. The mean of the
observations is shown as the thick gray line in the rainbow plot. This
mean is used to center the data for PCA. Although the data is observed
at 101 points each year for 207 years, only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>
components are needed to explain 95% of the total variation; see skree
plot. The first two PCs are also shown with the related
coefficients.</p>
<div class="float">
<img src="functionaldata/fmortality_pc2.png" style="width:5in" alt="The first PC."><div class="figcaption"><strong><em>The first PC.</em></strong></div>
</div>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pca_data</span><span class="op">$</span><span class="va">rotation</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, xlab <span class="op">=</span> <span class="cn">NA</span>, ylab <span class="op">=</span> <span class="cn">NA</span>, cex.axis <span class="op">=</span> <span class="fl">2</span>, type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/fmortality_pc2.png" style="width:5in" alt="The second PC."><div class="figcaption"><strong><em>The second PC.</em></strong></div>
</div>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pca_data</span><span class="op">$</span><span class="va">rotation</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, xlab <span class="op">=</span> <span class="cn">NA</span>, ylab <span class="op">=</span> <span class="cn">NA</span>, cex.axis <span class="op">=</span> <span class="fl">2</span>, type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="functionaldata/fmortality_coef1.png" style="width:5in" alt="The first PC scores.">```{r eval=FALSE}</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pca_data</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, xlab <span class="op">=</span> <span class="cn">NA</span>, ylab <span class="op">=</span> <span class="cn">NA</span>, cex.axis <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/fmortality_coef2.png" style="width:5in" alt="The second PC scores."><div class="figcaption"><strong><em>The second PC
scores.</em></strong></div>
</div>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pca_data</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, xlab <span class="op">=</span> <span class="cn">NA</span>, ylab <span class="op">=</span> <span class="cn">NA</span>, cex.axis <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="exercises">Exercises<a class="anchor" aria-label="anchor" href="#exercises"></a>
</h3>
<p>The data for these exercises can be downloaded as given at the start
of this document. These data comprise electricity spot prices in
Germany:</p>
<ol style="list-style-type: decimal">
<li><p>Coerce the data into a dfts object and plot the raw
data.</p></li>
<li><p>Turn the data into functional data objects using b-spline
smoothing and Fourier basis smoothing. Try different values of the
smoothing parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
and observe the results.</p></li>
<li><p>Compute the mean and first three functional principal components.
Compute a scree plot for this data; how many principal components are
needed to explain 95% of the total variation of the data?</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="forecasting-functional-time-series">Forecasting functional time series<a class="anchor" aria-label="anchor" href="#forecasting-functional-time-series"></a>
</h2>
<p>Suppose that we are given a functional time series (FTS)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mspace width="0.278em"></mspace><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{X_i(t),\; i\in\{1,...,T\}, \; t\in[0,1]\}</annotation></semantics></math>,
which we have perhaps obtained after applying pre-processing as
introduced in Section <a href="#sec-pre" reference-type="ref" reference="sec-pre">1.3</a>. In this chapter we study methods to
forecast the time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
steps ahead, or in other words predict the curve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow></msub><annotation encoding="application/x-tex">X_{T+h}</annotation></semantics></math>,
as well as quantify the uncertainty in such a forecast.</p>
<div class="section level3">
<h3 id="the-hyndman-ullah-method">The Hyndman-Ullah method<a class="anchor" aria-label="anchor" href="#the-hyndman-ullah-method"></a>
</h3>
<p>Although many methods have been introduced in the last approximately
20 years to forecast FTS, we will focus in this short course on the
“Hyndman-Ullah" method <span class="citation">(Hyndman and Ullah
2007)</span>. The idea behind this method is simple <strong>—</strong>
if we suppose that the underlying curves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
may be well-approximated by their projection onto the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
eigenfunctions of the covariance operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>J</mi></msub></mrow><annotation encoding="application/x-tex">\hat{v}_1,...,\hat{v}_J</annotation></semantics></math>,
so that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>J</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    X_i(t) \approx X_i^{(J)}(t) = \hat{\mu}(t) + \sum_{j=1}^J {\xi}_{i, j} \hat{v}_{j}(t),
\end{aligned}</annotation></semantics></math> then the time dynamics of
the series are characterized by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
scalar time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mi>J</mi></mrow></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">{\xi}_{i, 1},...,{\xi}_{i, J}.</annotation></semantics></math>
Forecasts for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
may then be reduced to forecasting these
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
scalar time series. Forecasting scalar time series is of course a very
well understood problem, and there are a host of methods that can be
used to produce forecasts of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>J</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\xi_{T+h,1},...,\xi_{T+h,J}</annotation></semantics></math>,
which we denote
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>J</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat{\xi}_{T+h,1},...,\hat{\xi}_{T+h,J}</annotation></semantics></math>.
This leads to the forecast of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mover><mi>ξ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>j</mi></mrow></msub><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \hat{X}_{T+h}(t) = \hat{\mu}(t) + \sum_{j=1}^J \hat{\xi}_{T+h, j} \hat{v}_{j}(t). 
\end{aligned}</annotation></semantics></math>.</p>
<p>Such forecasts are quite hard to interpret alone without some
quantification of the uncertainty we expect in them. A simple way
quantify the uncertainty in the forecast is to employ simulation. Many
methods to produce forecasts of the component series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\xi_{i,j}</annotation></semantics></math>
are “model based", and readily lend themselves to simulating potential
future values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mn>1</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>J</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\xi^{(b)}_{T+h,1},...,\xi^{(b)}_{T+h,J}</annotation></semantics></math>,
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">b \in \{1,...,B\}</annotation></semantics></math>.
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is a user-specified large value that defines how many simulated future
curves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow></msub><annotation encoding="application/x-tex">X_{T+h}</annotation></semantics></math>
we produce. Using simulations of the component series, we may simulate
the FTS as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>j</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat{X}^{(b)}_{T+h}(t) = \hat{\mu}(t) + \sum_{j=1}^J {\xi}^{(b)}_{T+h, j} \hat{v}_{j}(t), \;\; b\in \{1,...,B\}.</annotation></semantics></math></p>
<p>By examining the variability of these simulated curves, we can get an
idea of how much variability we might expect of future curves as well as
how much they might deviate from the forecasted curve. For example, a
pointwise in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
95% prediction interval for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_{T+h}(t)</annotation></semantics></math>
is constructed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.025</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.975</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">X_{T+h}(t) \in (\hat{q}(0.025),\hat{q}(0.975) ),</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{q}(\alpha)</annotation></semantics></math>
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
sample quantile of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\hat{X}^{(b)}_{T+h}(t),</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">b\in \{1,...,B\}</annotation></semantics></math>.</p>
<p><em>Remark</em>: We note that a model that takes into account the
“dimension reduction error" in HU is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">X_i(t) =\hat{\mu}(t) + \sum_{j=1}^J {\xi}_{i, j} \hat{v}_{j}(t) + \varepsilon_i(t),</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon_i(t)</annotation></semantics></math>
is a”functional residual"
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>J</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\varepsilon_i(t)= X_i(t) - X_i^{(J)}(t).</annotation></semantics></math>
By taking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
large (or equivalently taking the TVE to be large in the PCA dimension
reduction),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\varepsilon_i</annotation></semantics></math>
can be made smaller. Often though because it requires a more complex
models of the component series we may not wish to take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
too large, and so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\varepsilon_i</annotation></semantics></math>
may be non-negligible. In order to incorporate this into the uncertainty
quantification of the forecast, we can compute simulated curves as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>μ</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>j</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><msub><mover><mi>v</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>ε</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">\hat{X}^{(b)}_{T+h}(t) = \hat{\mu}(t) + \sum_{j=1}^J {\xi}^{(b)}_{T+h, j} \hat{v}_{j}(t) + \varepsilon_{T+h}^{(b)}(t), \;\; b\in \{1,...,B\},</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ε</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon_{T+h}^{(b)}(t)</annotation></semantics></math>
is an iid draw from the residuals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>X</mi><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>J</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">X_i(t) - X_i^{(J)}(t), \; i \in \{1,...,T\}.</annotation></semantics></math></p>
<p><em>Remark</em>: Often when we simulate the component series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mn>1</mn></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>ξ</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>J</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\xi^{(b)}_{T+h,1},...,\xi^{(b)}_{T+h,J}</annotation></semantics></math>,
we do this <em>independently across the series</em>. Whether this is
reasonable to do is often unclear. When the component series are
constructed using PCA, the series are marginally uncorrelated, although
can exhibit complex temporal dependency structures.</p>
</div>
<div class="section level3">
<h3 id="forecasting-the-component-series">Forecasting the component series<a class="anchor" aria-label="anchor" href="#forecasting-the-component-series"></a>
</h3>
<p>The Hyndman<strong>–</strong>Ullah method relies on forecasting the
scalar series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ξ</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\xi_{i,j}</annotation></semantics></math>.
We now discuss two simple and automated methods to do so in
<code>R</code>. Further summaries of these models can be found in <span class="citation">(Hyndman and Khandakar 2008)</span>.</p>
<div class="section level4">
<h4 id="sarima-and-the-autoarima-model">SARIMA and the <code>autoarima</code> model<a class="anchor" aria-label="anchor" href="#sarima-and-the-autoarima-model"></a>
</h4>
<p>ARIMA models, and their seasonal versions, have been a mainstay of
time series analysis since the seminal work of Box and Jenkins <span class="citation">(Box and Jenkins 1970)</span>. These models assume that
the underlying scalar time series of interest
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
is in essence a linear function of a <em>strong white noise
sequence</em>.</p>
<p><em>Definition</em>: We say
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>t</mi></msub><annotation encoding="application/x-tex">w_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">t\in \mathbb{Z}</annotation></semantics></math>
is a strong white noise if it is a sequence of mean zero, independent,
and identically distributed random variables with finite variance.</p>
<p>The <em>backshift operator</em> is denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
and is defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>j</mi></msup><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mi>j</mi></mrow></msub><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>j</mi><mo>≥</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">B^jx_t = x_{t-j}, \;\; j\ge 0.</annotation></semantics></math></p>
<p>Two guiding examples to consider in forecasting are the “strong white
noise model",
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>μ</mi><mo>+</mo><msub><mi>w</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    x_t = \mu + w_t,
\end{aligned}</annotation></semantics></math> and the”random walk model"
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>μ</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi><msub><mi>μ</mi><mn>1</mn></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><msub><mi>w</mi><mi>j</mi></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    x_t = \mu_0 + t \mu_1 + \sum_{j=1}^t w_j. 
\end{aligned}</annotation></semantics></math>.</p>
<p>In the case of the first model, the best predictor of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math>
given past values of the series is the mean value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>,
which can be estimated from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_{n-1}</annotation></semantics></math>
by the sample mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>x</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{x}</annotation></semantics></math>.
The second model on the other hand can be rewritten as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>μ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>w</mi><mi>t</mi></msub><mspace width="0.278em"></mspace><mo>⇔</mo><mspace width="0.278em"></mspace><mi>∇</mi><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>μ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mi>t</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">x_t = \mu_1 + x_{t-1} + w_t  \; \iff \; \nabla x_{t} =  x_t - x_{t-1} = (1-B)x_t=  \mu_1 + w_t,</annotation></semantics></math>
which makes clear that the best forecast for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math>
based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_{n-1},...,x_1</annotation></semantics></math>
in this case is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>μ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_{n-1} + \mu_1</annotation></semantics></math>.
The second model is also called an “integrated model", since the
differenced values of the times series are a white noise and can be
added (integrated) up to recover the original series. ARIMA models in
essence choose between these two models while also allowing for
additional serial correlation in the series.</p>
<p>Given a white noise sequence
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>w</mi><mi>t</mi></msub><mspace width="0.278em"></mspace><mo>,</mo><mspace width="0.278em"></mspace><mi>t</mi><mo>∈</mo><mi>ℤ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{w_t\;,\; t\in \mathbb{Z}\}</annotation></semantics></math>,
a moving average process of order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
(MA(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>))
is of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>w</mi><mi>t</mi></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mi>B</mi><msub><mi>w</mi><mi>t</mi></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>θ</mi><mi>q</mi></msub><msup><mi>B</mi><mi>q</mi></msup><msub><mi>w</mi><mi>t</mi></msub><mo>=</mo><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>w</mi><mi>t</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">x_t = w_t + \theta_1 B w_t + \cdots  + \theta_qB^q w_t = \theta(B)w_t,</annotation></semantics></math>
where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>θ</mi><mi>q</mi></msub><msup><mi>x</mi><mi>q</mi></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">\theta(x) = 1 + \theta_1 x + \cdots +\theta_q x^q.</annotation></semantics></math>
An <em>AutoRegressive process of order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math></em>,
denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">AR(p)</annotation></semantics></math>,
is defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>ϕ</mi><mn>1</mn></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>ϕ</mi><mi>p</mi></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mi>p</mi></mrow></msub><mo>+</mo><msub><mi>w</mi><mi>t</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">x_t = \phi_1 x_{t-1} + \cdots + \phi_p x_{t-p} + w_t.</annotation></semantics></math>
We define the <em>autoregressive polynomial</em> as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mi>x</mi><mo>−</mo><mi>⋯</mi><mo>−</mo><msub><mi>ϕ</mi><mi>p</mi></msub><msup><mi>x</mi><mi>p</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">\phi(x) = 1-\phi_1 x - \cdots - \phi_p x^p,</annotation></semantics></math>
so the AR(p) process is characterized by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><msub><mi>w</mi><mi>t</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\phi(B)x_t = w_t.</annotation></semantics></math>
An ARMA (autoregressive moving average) model is of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>w</mi><mi>t</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\phi(B)x_t = \theta(B) w_t.</annotation></semantics></math></p>
<p><em>Definition</em>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
is said to follow an SARIMA (Seasonal Autoregressive Integrated Moving
Average) model of orders
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and seasonal period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
if
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Φ</mi><mi>P</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>B</mi><mi>s</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msup><mi>B</mi><mi>s</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>D</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi></msup><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>B</mi><mi>s</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>w</mi><mi>t</mi></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}   
        \Phi_P(B^s)\phi(B)(1-B^s)^D(1-B)^d x_t = \Theta(B^s)\theta(B)w_t.
\end{aligned}</annotation></semantics></math> This is abbreviated
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∼</mo><mi>S</mi><mi>A</mi><mi>R</mi><mi>I</mi><mi>M</mi><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>d</mi><mo>,</mo><mi>q</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>P</mi><mo>,</mo><mi>D</mi><mo>,</mo><mi>Q</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">x_t \sim SARIMA(p,d,q)\times (P,D,Q)_s</annotation></semantics></math>.</p>
<p>The seasonal period is typically supplied by the practitioner and is
often chosen to match the predominant “seasonality" or”periodicity" in
the series. For instance with daily data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">s=7</annotation></semantics></math>
might be used to model weekly seasonality. This is typically achieved in
<code>R</code> by specifying the <code>frequency</code> parameter of at
time series object.</p>
<p>Here we use the function <code>auto.arima</code> from the
<code>forecast</code> and <code>fpp2</code> packages in <code>R</code>
to select and fit such models. This function first selects the
differencing degrees
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
via applying a KPSS stationarity <span class="citation">(Kwiatkowski et
al. 1992)</span> test to the time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\nabla x_t</annotation></semantics></math>.
The ARMA orders
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>,</mo><mi>q</mi><mo>,</mo><mi>P</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">p,q, P,</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
are selected using the AIC information criterion, and the model
parameters are estimated via maximum likelihood estimation assuming the
model errors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>t</mi></msub><annotation encoding="application/x-tex">w_t</annotation></semantics></math>
are Gaussian.</p>
<p>We note that by simulating the error process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>t</mi></msub><annotation encoding="application/x-tex">w_t</annotation></semantics></math>
and iterating the recursion for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
in SARIMA, we can simulate approximate future values of the series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>x</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">x_{T+h}^{(b)}</annotation></semantics></math>.</p>
</div>
<div class="section level4">
<h4 id="exponential-smoothing-and-the-ets-model">Exponential Smoothing and the <code>ets</code> model<a class="anchor" aria-label="anchor" href="#exponential-smoothing-and-the-ets-model"></a>
</h4>
<p>Exponential smoothing was introduced in the late 1950’s. The basic
principle behind exponential smoothing is that for a time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_n</annotation></semantics></math>,
two extreme forecasts are again</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mo>→</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> random walk prediction </mtext><mspace width="0.333em"></mspace></mrow></mrow><annotation encoding="application/x-tex">\hat{x}_{n+1}  = x_n  \;\; \longrightarrow \mbox{ random walk prediction }</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mi>n</mi></mfrac><msub><mi>x</mi><mi>j</mi></msub><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mo>→</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> iid noise prediction. </mtext><mspace width="0.333em"></mspace></mrow></mrow><annotation encoding="application/x-tex">\hat{x}_{n+1}  =\bar{x}= \sum_{j=1}^{n}  \frac{1}{n} x_j \;\; \longrightarrow \mbox{ iid noise prediction. }</annotation></semantics></math>
We notice that both of these forecasts are weighted linear combinations
of the past values of the series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_n</annotation></semantics></math>:
the random walk model puts full weight on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math>,
whereas the iid noise model puts even weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">1/n</annotation></semantics></math>
on each value.<br>
For general time series the optimal prediction might fall between these
extremes. Exponential smoothing models generally suppose that these
weights decay geometrically.<br><strong>Simple Exponential Smoothing:</strong> We forecast
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math>
with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>α</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex">\hat{x}_{n+1} = \alpha x_n + \alpha (1-\alpha)x_{n-1} + \alpha(1-\alpha)^2 x_{n-2} + \cdots</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>α</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le \alpha \le 1</annotation></semantics></math>.
This prediction may be restated as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> Forecast Equation </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mo>ℓ</mo><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> Smoothing Equation </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><msub><mo>ℓ</mo><mi>n</mi></msub><mo>=</mo><mi>α</mi><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mo>ℓ</mo><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mo>,</mo><msub><mo>ℓ</mo><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> Initial Condition </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left" style="text-align: left"><mspace width="1.0em"></mspace><msub><mo>ℓ</mo><mn>0</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \mbox{ Forecast Equation }&amp; \quad   \hat{x}_{n+1}   = \ell_n \\
    \mbox{ Smoothing Equation  }&amp;   \quad \ell_n   = \alpha x_n + (1-\alpha)\ell_{n-1} =\ell_n(\alpha,\ell_0) \\
    \mbox{ Initial Condition  }&amp;   \quad \ell_0
\end{aligned}</annotation></semantics></math></p>
<p>Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mo>ℓ</mo><mn>0</mn></msub><annotation encoding="application/x-tex">\ell_0</annotation></semantics></math>
are the scalar parameters defining this prediction, and can be estimated
via least squares:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>α</mi><mo accent="true">̂</mo></mover><mo>,</mo><msub><mover><mo>ℓ</mo><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>arg</mo><munder><mo>min</mo><mrow><mn>0</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1</mn><mo>,</mo><msub><mi>l</mi><mn>0</mn></msub></mrow></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mo>ℓ</mo><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><msub><mi>l</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(\hat{\alpha},\hat{\ell}_0) = \arg\min_{0\le a \le 1, l_0} \sum_{i=2}^{n}(x_i - \ell_i(a,l_0))^2</annotation></semantics></math></p>
<p><strong>Linear Trend Exponential Smoothing:</strong> In order to make
a forecast
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
steps ahead, we extrapolate the trend linearly as follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Forecast equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mo>ℓ</mo><mi>n</mi></msub><mo>+</mo><mi>m</mi><msub><mi>b</mi><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Level equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mo>ℓ</mo><mi>n</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>α</mi><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Trend/Slope equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>b</mi><mi>n</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mi>n</mi></msub><mo>−</mo><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
      \text{Forecast equation}&amp;&amp; \hat{x}_{n+m} &amp;= \ell_{n} + mb_{n} \\
    \text{Level equation}   &amp;&amp; \ell_{n}       &amp;= \alpha x_{n} + (1 - \alpha)(\ell_{n-1} + b_{n-1})\\
      \text{Trend/Slope equation}   &amp;&amp; b_{n}          &amp;= \beta(\ell_{n} - \ell_{n-1}) + (1 -\beta)b_{n-1},
\end{aligned}</annotation></semantics></math> Scalar Parameters:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi><mo>,</mo><msub><mo>ℓ</mo><mn>0</mn></msub><mo>,</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\alpha,\beta, \ell_0,b_0</annotation></semantics></math>
can once again be estimated using least squares.</p>
<p><strong>Trend+Seasonal Exponential Smoothing (Holt-Winters
ES):</strong> If a time series exhibits seasonality at period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
then we incorporate it into the forecast as follows. Letting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false" form="prefix">⌊</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>p</mi><mo stretchy="false" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">k=\lfloor (m-1)/p \rfloor</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Forecast equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mover><mi>x</mi><mo accent="true">̂</mo></mover><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mo>ℓ</mo><mi>n</mi></msub><mo>+</mo><mi>m</mi><msub><mi>b</mi><mi>n</mi></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>−</mo><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Level equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mo>ℓ</mo><mi>n</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mi>p</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Trend equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>b</mi><mi>n</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>ℓ</mo><mi>n</mi></msub><mo>−</mo><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Seasonal equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>s</mi><mi>n</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>γ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mo>ℓ</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>γ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mi>p</mi></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \text{Forecast equation} &amp;&amp; \hat{x}_{n+m}  &amp;= \ell_{n} + mb_{n} + s_{n+m-p(k+1)} \\
    \text{Level equation}&amp;&amp;  \ell_{n} &amp;= \alpha(x_{n} - s_{n-p}) + (1 - \alpha)(\ell_{n-1} + b_{n-1})\\
    \text{Trend equation}&amp;&amp;  b_{n} &amp;= \beta(\ell_{n} - \ell_{n-1}) + (1 - \beta)b_{n-1}\\
    \text{Seasonal equation}&amp;&amp;  s_{n} &amp;= \gamma (x_{n}-\ell_{n-1}-b_{n-1}) + (1-\gamma)s_{n-p},
\end{aligned}</annotation></semantics></math> Scalar Parameters:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi><mo>,</mo><mi>γ</mi><mo>,</mo><msub><mo>ℓ</mo><mn>0</mn></msub><mo>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>,</mo><msub><mi>s</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>s</mi><mrow><mo>−</mo><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha,\beta,\gamma, \ell_0,b_0,s_0,...,s_{-p+1}</annotation></semantics></math>
can be estimated using least squares.</p>
<p>We note that each of these models may be rewritten in what is called
“state-space" or”innovations" form. For example, the simple exponential
smoothing model may be rewritten as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">Observation equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>x</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mo>ℓ</mo><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ε</mi><mi>t</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">State equation</mtext></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"><msub><mo>ℓ</mo><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mo>ℓ</mo><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>α</mi><msub><mi>ε</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \text{Observation equation} &amp;&amp; x_t &amp;= \ell_{t-1} + \varepsilon_t \\
    \text{State equation} &amp;&amp;  \ell_t&amp;=\ell_{t-1}+\alpha \varepsilon_t,
\end{aligned}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\varepsilon_t</annotation></semantics></math>
is an innovation sequence representing the residuals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>−</mo><msub><mo>ℓ</mo><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_t - \ell_{t-1}</annotation></semantics></math>.
By assuming for instance that these residuals are Gaussian, one can once
again easily simulate future values of the series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>x</mi><mrow><mi>T</mi><mo>+</mo><mi>h</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">x_{T+h}^{(b)}</annotation></semantics></math>
as well as conduct model selection using information criteria such as
AIC.</p>
<p>The <code>ets()</code> function from the <code>fpp2</code> package in
<code>R</code> fits such exponential smoothing models using least
squares and conducting model selection between standard, linear trend,
and seasonal/Holt-Winters models using AIC. We note this function also
chooses among “multiplicative seasonality" versions of the same models.
A multiplicative Holt-Winters model for a non-negative time series can
be more appropriate if the seasonal/periodic fluctuations of the series
increase (or decrease) as a function of the level of the series.</p>
</div>
</div>
<div class="section level3">
<h3 id="time-series-cross-validation">Time Series Cross-Validation<a class="anchor" aria-label="anchor" href="#time-series-cross-validation"></a>
</h3>
<p>A useful tool choosing between such models is to use <em>time series
cross-validation</em>. Suppose we wish to evaluate the quality of a
model choice
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>.
For example, we might wish to compare SARIMA and Exponential smoothing
to produce forecasts. We proceed as follows:</p>
<ol style="list-style-type: decimal">
<li><p>Select training, validation, and testing ranges,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>t</mi><mi>r</mi><mo>≤</mo><mi>v</mi><mo>≤</mo><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo>≤</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">1 \le tr \le v \le test \le T</annotation></semantics></math>,
e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>70</mn><mi>%</mi><mo>,</mo><mn>15</mn><mi>%</mi><mo>,</mo><mn>15</mn><mi>%</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(70\%,15\%,15\%)</annotation></semantics></math>
of the data. Note: In forecasting applications we often forego the
testing set and just use training and validation sets.</p></li>
<li><p>For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>t</mi><mi>r</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">j \in \{tr,...,v\}</annotation></semantics></math>,
forecast
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\hat{X}_{j+1}</annotation></semantics></math>
based on the curves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_1,...,X_j</annotation></semantics></math>
using model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>,
or if we are interested in horizon
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
forecasting forecast
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>j</mi><mo>+</mo><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat{X}_{j+1},...,\hat{X}_{j+h}</annotation></semantics></math>.
Calculate losses
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>X</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mi>d</mi><mi>t</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">L_j(g) =  \int_0^1 [X_j(t) - \hat{X}_j(t)]^2 dt,</annotation></semantics></math>
or
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mo>ℓ</mo><mo>=</mo><mn>1</mn></mrow><mi>h</mi></munderover><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>X</mi><mrow><mi>j</mi><mo>+</mo><mo>ℓ</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">̂</mo></mover><mrow><mi>j</mi><mo>+</mo><mo>ℓ</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mi>d</mi><mi>t</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">L_j(g) =  \sum_{\ell =1 }^h \int_0^1 [X_{j+\ell}(t) - \hat{X}_{j+\ell}(t)]^2 dt.</annotation></semantics></math></p></li>
<li><p>A CV loss score for the model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
can be taken as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>V</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>−</mo><mi>t</mi><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>t</mi><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>v</mi></munderover><msub><mi>L</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">CV(g) = \frac{1}{(v-tr)}\sum_{j=tr+1}^{v}L_j(g).</annotation></semantics></math>
Small values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>V</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CV(g)</annotation></semantics></math>
suggest better performance.</p></li>
</ol>
<p>This type of time series cross-validation is often called “expanding
window" cross-validation, since we forecast
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>j</mi></msub><annotation encoding="application/x-tex">X_j</annotation></semantics></math>
at each stage using all of the previous data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">X_1,...,X_j</annotation></semantics></math>.
A schematic of how this works is shown in Figure <a href="#expw" reference-type="ref" reference="expw">2.1</a>.</p>
<div class="float" id="expw">
<img src="functionaldata/ts_cv.png" style="width:5in" alt='“Expanding window" Time Series Cross-Validation Diagram.'><div class="figcaption"><strong><em>“Expanding window" Time Series
Cross-Validation Diagram.</em></strong></div>
</div>
</div>
<div class="section level3">
<h3 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h3>
<div class="section level4">
<h4 id="electricity-prices">Electricity Prices<a class="anchor" aria-label="anchor" href="#electricity-prices"></a>
</h4>
<p>Suppose that the goal was to forecast the electricity prices shown
previously for the next month. It is natural to assume this data has
weekly seasonality due to the typical work schedule. Using PCA as
discussed in Section <a href="#ch1" reference-type="ref" reference="ch1">1</a>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>7</mn><annotation encoding="application/x-tex">7</annotation></semantics></math>
PCs can be used to explain over 99% of the variation in the data.
Figures below show forecasts for the first two PCs and the entire
electricity data using ets and arima Hyndman-Ullah models. Although
differentiating the models visualizing is difficult, one-step CV one the
last 20% of the data gives MSE estimates of approximately 2280 (ets) and
2522 (arima), suggesting the use of an ets model gives about a 10%
improvement.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_ets</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="va">electricity</span>, forecast.model <span class="op">=</span> <span class="st">"ets"</span>, TVE <span class="op">=</span> <span class="fl">0.99</span>,</span>
<span>  n.ahead <span class="op">=</span> <span class="fl">14</span>, check.cp <span class="op">=</span> <span class="cn">F</span>, alpha <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>  sim.bounds <span class="op">=</span> <span class="cn">TRUE</span>, M <span class="op">=</span> <span class="fl">1000</span></span>
<span><span class="op">)</span></span>
<span><span class="va">elec_arima</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="va">electricity</span>, forecast.model <span class="op">=</span> <span class="st">"arima"</span>, TVE <span class="op">=</span> <span class="fl">0.99</span>,</span>
<span>  n.ahead <span class="op">=</span> <span class="fl">14</span>, check.cp <span class="op">=</span> <span class="cn">F</span>, alpha <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>  sim.bounds <span class="op">=</span> <span class="cn">TRUE</span>, M <span class="op">=</span> <span class="fl">1000</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># CV</span></span>
<span><span class="va">pred_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor</a></span><span class="op">(</span><span class="fl">0.8</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"fets"</span>, <span class="st">"farima"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"CV ("</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, <span class="st">"):"</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">i</span>, <span class="st">", "</span><span class="op">)</span></span>
<span>  <span class="va">idx</span> <span class="op">&lt;-</span> <span class="va">pred_idx</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">idx</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span>  <span class="va">tmp_pred</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span><span class="va">idx</span><span class="op">]</span></span>
<span>  <span class="va">tmp_pred</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span></span>
<span>  <span class="va">pm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    <span class="st">"fets"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farima"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="op">(</span><span class="va">ests</span> <span class="op">-</span> <span class="va">tmp_pred</span><span class="op">$</span><span class="va">data</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#  fets  farima</span></span>
<span><span class="co"># 1.000  1.106</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_ets1.png" style="width:5in" alt="The first PC for ets model of electricity."><div class="figcaption"><strong><em>The first PC for ets model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_ets</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">components</span><span class="op">$</span><span class="va">`Component 1`</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_ets2.png" style="width:5in" alt="The second PC for ets model of electricity."><div class="figcaption"><strong><em>The second PC for ets model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_ets</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">components</span><span class="op">$</span><span class="va">`Component 2`</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_ets.png" style="width:5in" alt="The ets model of electricity."><div class="figcaption"><strong><em>The ets model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_ets</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_arima1.png" style="width:5in" alt="The first PC for arima model of electricity."><div class="figcaption"><strong><em>The first PC for arima model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_arima</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">components</span><span class="op">$</span><span class="va">`Component 1`</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_arima2.png" style="width:5in" alt="The second PC for arima model of electricity."><div class="figcaption"><strong><em>The second PC for arima model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_arima</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">components</span><span class="op">$</span><span class="va">`Component 2`</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_arima.png" style="width:5in" alt="The arima model of electricity."><div class="figcaption"><strong><em>The arima model of
electricity.</em></strong></div>
</div>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elec_arima</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span></code></pre></div>
<p>It may also make sense to transform the data. This can be done
manually or using a currently under development parameter
<code>transformation</code> as shown below.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">electricity</span>, check.cp <span class="op">=</span> <span class="cn">FALSE</span>, n.ahead <span class="op">=</span> <span class="fl">14</span><span class="op">)</span></span>
<span><span class="va">fit_log</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">electricity</span>,</span>
<span>  transformation <span class="op">=</span> <span class="st">"log"</span>, check.cp <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  n.ahead <span class="op">=</span> <span class="fl">14</span></span>
<span><span class="op">)</span></span>
<span><span class="va">fit_sqrt</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">electricity</span>,</span>
<span>  transformation <span class="op">=</span> <span class="st">"sqrt"</span>, check.cp <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  n.ahead <span class="op">=</span> <span class="fl">14</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># With fitted data</span></span>
<span><span class="va">fit</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">fit_plot</span></span>
<span><span class="va">fit_log</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">fit_plot</span></span>
<span><span class="va">fit_sqrt</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">fit_plot</span></span>
<span></span>
<span><span class="co"># With original data</span></span>
<span><span class="va">fit</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span>
<span><span class="va">fit_log</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span>
<span><span class="va">fit_sqrt</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span></code></pre></div>
<p>Running CV with log and sqrt root data, returns the following
results: 1.000 (fets), 1.106 (farima), 1.460 (log fets), 1.367 (log
farima), 1.119 (sqrt fets), and 1.153 (sqrt fets).</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># CV with all</span></span>
<span><span class="va">pred_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor</a></span><span class="op">(</span><span class="fl">0.8</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"fets"</span>, <span class="st">"farima"</span>, <span class="st">"fetsLog"</span>, <span class="st">"farimaLog"</span>, <span class="st">"fetsSqrt"</span>, <span class="st">"farimaSqrt"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"CV ("</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, <span class="st">"):"</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">i</span>, <span class="st">", "</span><span class="op">)</span></span>
<span>  <span class="va">idx</span> <span class="op">&lt;-</span> <span class="va">pred_idx</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">idx</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span>  <span class="va">tmp_pred</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span><span class="va">idx</span><span class="op">]</span></span>
<span>  <span class="va">tmp_pred</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span></span>
<span>  <span class="va">pm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm5</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"sqrt"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm6</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"sqrt"</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    <span class="st">"fets"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farima"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"fetsLog"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farimaLog"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"fetsSqrt"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm5</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farimaSqrt"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm6</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span><span class="op">]</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="op">(</span><span class="va">ests</span> <span class="op">-</span> <span class="va">tmp_pred</span><span class="op">$</span><span class="va">data</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#   fets   farima  fetsLog  farimaLog   fetsSqrt farimaSqrt</span></span>
<span><span class="co">#  1.000   1.106   1.460    1.367       1.119     1.153</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="pollution">Pollution<a class="anchor" aria-label="anchor" href="#pollution"></a>
</h4>
<p>Consider the pollution data. This time we will compare a functional
approach to traditional methods. CV with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>7</mn><annotation encoding="application/x-tex">7</annotation></semantics></math>
day forecasts are used. Scaled CV results were: 1.101 (arima), 2.453
(ets), 1.450 (fets), 1.000 (farima), 1.271 (log fets), and 1.031 (log
arima).</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Forecast horizon: 7 days * 48 half hours = 336 pts</span></span>
<span><span class="va">h</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span></span>
<span><span class="co"># CV</span></span>
<span><span class="va">pred_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span> <span class="op">-</span> <span class="fl">13</span><span class="op">:</span><span class="fl">7</span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"arima"</span>, <span class="st">"ets"</span>, <span class="st">"fets"</span>, <span class="st">"farima"</span>, <span class="st">"fets_log"</span>, <span class="st">"farima_log"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"CV ("</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, <span class="st">"):"</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">i</span>, <span class="st">", "</span><span class="op">)</span></span>
<span>  <span class="va">tmp_dat</span> <span class="op">&lt;-</span> <span class="va">city_dfts</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="va">pred_idx</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span>  <span class="va">tmp_scalar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">tmp_dat</span><span class="op">$</span><span class="va">data</span><span class="op">)</span>, frequency <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></span>
<span>  <span class="va">tmp_pred</span> <span class="op">&lt;-</span> <span class="va">city_dfts</span><span class="op">[</span>, <span class="va">pred_idx</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">:</span><span class="fl">7</span><span class="op">]</span></span>
<span></span>
<span>  <span class="va">scalar_arima</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/auto.arima.html" class="external-link">auto.arima</a></span><span class="op">(</span><span class="va">tmp_scalar</span><span class="op">)</span></span>
<span>  <span class="va">arima_for</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://generics.r-lib.org/reference/forecast.html" class="external-link">forecast</a></span><span class="op">(</span><span class="va">scalar_arima</span>, h <span class="op">=</span> <span class="va">h</span> <span class="op">*</span> <span class="fl">48</span>, level <span class="op">=</span> <span class="fl">95</span><span class="op">)</span></span>
<span>  <span class="va">scalar_ets</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/ets.html" class="external-link">ets</a></span><span class="op">(</span><span class="va">tmp_scalar</span><span class="op">)</span></span>
<span>  <span class="va">ets_for</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://generics.r-lib.org/reference/forecast.html" class="external-link">forecast</a></span><span class="op">(</span><span class="va">scalar_ets</span>, h <span class="op">=</span> <span class="va">h</span> <span class="op">*</span> <span class="fl">48</span>, level <span class="op">=</span> <span class="fl">95</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">pm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    <span class="st">"arima"</span> <span class="op">=</span> <span class="va">arima_for</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>    <span class="st">"ets"</span> <span class="op">=</span> <span class="va">ets_for</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>    <span class="st">"fets"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">tmp_dat</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farima"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">tmp_dat</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"fetsL"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">tmp_dat</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farimaL"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">tmp_dat</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="op">(</span><span class="va">ests</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">tmp_pred</span><span class="op">$</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#  arima   ets    fets  farima  fets_log  farima_log</span></span>
<span><span class="co">#  1.101  2.453  1.196  1.000   1.271     1.031</span></span></code></pre></div>
<p>In this case, we know the true errors. When forecasting and comparing
to the truth for the next week, similar results are seen: 1.376 (arima),
1.601 (ets), 1.450 (fets), 1.000 (farima), 1.866 (log fets), and 1.073
(log arima). It is clear arima models are better choices than ets for
the pollution.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Results</span></span>
<span><span class="va">tmp_scalar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">$</span><span class="va">data</span><span class="op">)</span>, frequency <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></span>
<span></span>
<span><span class="va">scalar_arima</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/auto.arima.html" class="external-link">auto.arima</a></span><span class="op">(</span><span class="va">tmp_scalar</span><span class="op">)</span></span>
<span><span class="va">arima_for</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://generics.r-lib.org/reference/forecast.html" class="external-link">forecast</a></span><span class="op">(</span><span class="va">scalar_arima</span>, h <span class="op">=</span> <span class="va">h</span> <span class="op">*</span> <span class="fl">48</span>, level <span class="op">=</span> <span class="fl">95</span><span class="op">)</span></span>
<span><span class="va">scalar_ets</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/ets.html" class="external-link">ets</a></span><span class="op">(</span><span class="va">tmp_scalar</span><span class="op">)</span></span>
<span><span class="va">ets_for</span> <span class="op">&lt;-</span> <span class="fu">forecast</span><span class="fu">::</span><span class="fu"><a href="https://generics.r-lib.org/reference/forecast.html" class="external-link">forecast</a></span><span class="op">(</span><span class="va">scalar_ets</span>, h <span class="op">=</span> <span class="va">h</span> <span class="op">*</span> <span class="fl">48</span>, level <span class="op">=</span> <span class="fl">95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">city_dfts</span>,</span>
<span>  forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>  check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span><span class="op">)</span></span>
<span><span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">city_dfts</span>,</span>
<span>  forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>  check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span><span class="op">)</span></span>
<span><span class="va">pm3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">city_dfts</span>,</span>
<span>  forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>  check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">pm4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">city_dfts</span>,</span>
<span>  forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>  check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span>, transformation <span class="op">=</span> <span class="st">"log"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">ests_final</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  <span class="st">"arima"</span> <span class="op">=</span> <span class="va">arima_for</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>  <span class="st">"ets"</span> <span class="op">=</span> <span class="va">ets_for</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>  <span class="st">"fets"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>    <span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="op">)</span>,</span>
<span>  <span class="st">"farima"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>    <span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="op">)</span>,</span>
<span>  <span class="st">"fets7"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>    <span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="op">)</span>,</span>
<span>  <span class="st">"farima7"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>    <span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">city_dfts</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="va">true</span> <span class="op">&lt;-</span> <span class="fu">utils</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.csv</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"C:/Users/jerem/OneDrive/Documents/School/Waterloo/Research/RPackages/fChange/vignettes/articles/pollution_true.txt"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="op">(</span><span class="va">ests_final</span> <span class="op">-</span> <span class="va">true</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">res</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span>
<span><span class="co">#  arima   ets    fets  farima  fets_log  farima_log</span></span>
<span><span class="co">#  1.376  1.601  1.450  1.000   1.866     1.073</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/pollution_for.png" style="width:5in" alt="The pollution forecast model."><div class="figcaption"><strong><em>The pollution forecast
model.</em></strong></div>
</div>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">city_dfts</span>,</span>
<span>  forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="va">h</span>,</span>
<span>  check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span><span class="op">)</span></span>
<span><span class="va">mod</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="exercises-1">Exercises<a class="anchor" aria-label="anchor" href="#exercises-1"></a>
</h3>
<p>The data for these exercises can be downloaded as given at the start
of this document. These data comprise electricity spot prices in
Germany:</p>
<ol style="list-style-type: decimal">
<li><p>Forecast the data set three weeks ahead using the Hyndman-Ullah
method. Compare using the <code>autoarima</code> and <code>ets</code>
models to produce the component forecasts.</p></li>
<li><p>Run a cross-validation experiment to compare several model
choices, e.g. <code>autoarima</code> vs <code>ets</code>,
log-transforms, choice of TVE, etc.</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="ch3">Autocorrelation analyses, white noise, and stationarity testing<a class="anchor" aria-label="anchor" href="#ch3"></a>
</h2>
<p>In time series analysis we often seek to understand the serial
dependence structure of the series. This is useful in many respects: it
aids us in identifying periodicity in the series, it helps us to
investigate departures of the data from the stationarity assumption, and
it is useful in selecting an appropriate model. A related task is to
perform “goodness-of-fit" testing and model diagnostic checks to model
residuals to evalute the fidelity of the data to a given model. If for
instance forecasting model residuals exhibit significant serial
dependence, it seems possible that we could have constructed a better
model.</p>
<p>In this chapter we discuss several ways to investigate the serial
dependence structure of an FTS, as well as conduct other diagnostic
tests with FTS.</p>
<div class="section level3">
<h3 id="autocorrelation-measures">Autocorrelation measures<a class="anchor" aria-label="anchor" href="#autocorrelation-measures"></a>
</h3>
<p>One standard way to investigate the serial dependence of a time
series is in terms of serial correlation. The <em>autocovariance
operator at lag
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math></em>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h \ge 0</annotation></semantics></math>,
is defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Γ</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mo>∫</mo><msub><mi>γ</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>s</mi><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mi>x</mi><mo>∈</mo><msup><mi>L</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
    \Gamma_h(x)(t) := \int \gamma_h(t, s) x(s) ds, \ \ \ x\in L^2[0,1],</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma_h(t, s)</annotation></semantics></math>
is the autocovariance kernel defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mi>t</mi><mo>,</mo><mi>s</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\gamma_h(t,s) :=E [ (X_i(t)-\mu(t))(X_{i+h} (s)-\mu(s))],\ \ \ \ t,s \in [0,1].</annotation></semantics></math>
At lag zero,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Γ</mi><mn>0</mn></msub><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma_0 = C</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is the covariance operator in . The functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo>,</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\gamma_h(\cdot, \cdot)</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h\ge 0</annotation></semantics></math>,
characterize the serial correlation in the series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{ X_i\}</annotation></semantics></math>.
Given functional observations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">X_1,\ldots, X_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>γ</mi><mi>h</mi></msub><annotation encoding="application/x-tex">\gamma_h</annotation></semantics></math>
can be estimated using its sample counterpart
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>γ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>,</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>T</mi><mo>−</mo><mi>h</mi></mrow></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><mi>h</mi><mo>&lt;</mo><mi>T</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat\gamma_{T,h}(t,s):=\frac{1}{T}\sum_{i=1}^{T-h} (X_i(t)-\bar{X}_T(t))(X_{i+h}(s)-\bar{X}_T(s)), \ \ \ 0 \le h &lt; T.</annotation></semantics></math></p>
<p>A simple graphical summary of the serial dependence in the series can
be obtained by plotting
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>ρ</mi><mo accent="true">̂</mo></mover><mi>h</mi></msub><mo>=</mo><mfrac><mrow><mo stretchy="false" form="postfix">∥</mo><msub><mover><mi>γ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>,</mo><mi>h</mi></mrow></msub><msub><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msub></mrow><mrow><mo>∫</mo><msub><mover><mi>γ</mi><mo accent="true">̂</mo></mover><mrow><mi>T</mi><mo>,</mo><mn>0</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\hat{\rho}_h =\frac{\|\hat{\gamma}_{T,h}\|_2}{\int \hat{\gamma}_{T,0}(t,t)dt}
\end{aligned}</annotation></semantics></math> as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>,
which we refer to as the <em>functional autocorrelation function</em>
(fACF).</p>
<p>The coefficient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ρ</mi><mo accent="true">̂</mo></mover><mi>h</mi></msub><annotation encoding="application/x-tex">\hat\rho_h</annotation></semantics></math>
is a scale-free measure satisfying
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mover><mi>ρ</mi><mo accent="true">̂</mo></mover><mi>h</mi></msub><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le \hat\rho_h \le 1</annotation></semantics></math>,
and quantifies the strength of the serial correlation in a series. For a
function-valued white noise, we expect all autocorrelations at each
nonzero lag to be close to zero.</p>
<p>The function <code><a href="../reference/acf.html">acf()</a></code> when applied to a <code>dfts</code>
object plots the fACF as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">h = 1, \ldots, H</annotation></semantics></math>.
By default, the function plots
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math>
confidence bounds for the autocorrelation assuming the series forms a
strong white noise, as well as confidence bounds assuming the series is
drawn from a general function-valued weak white noise process that is
serially uncorrelated. The latter bounds are preferable for evaluating
the serial dependence of an FTS potentially exhibiting volatility
(conditional heteroscedasticity), for example those derived from
high-frequency asset prices.</p>
<p>A robust graphical summary of the serial dependence in an FTS is the
<em>functional spherical autocorrelation function</em> (fSACF). The
fSACF at lag
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
is computed by the average of the inner product of lagged pairs of the
series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><annotation encoding="application/x-tex">X_{i+h}</annotation></semantics></math>
that have been centered:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ρ</mi><mo accent="true">̃</mo></mover><mi>h</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>T</mi><mo>−</mo><mi>h</mi></mrow></munderover><mo stretchy="false" form="prefix">⟨</mo><mfrac><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover><mi>μ</mi><mo accent="true">̃</mo></mover></mrow><mrow><mo stretchy="false" form="postfix">∥</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover><mi>μ</mi><mo accent="true">̃</mo></mover><mo stretchy="false" form="postfix">∥</mo></mrow></mfrac><mo>,</mo><mfrac><mrow><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><mo>−</mo><mover><mi>μ</mi><mo accent="true">̃</mo></mover></mrow><mrow><mo stretchy="false" form="postfix">∥</mo><msub><mi>X</mi><mrow><mi>i</mi><mo>+</mo><mi>h</mi></mrow></msub><mo>−</mo><mover><mi>μ</mi><mo accent="true">̃</mo></mover><mo stretchy="false" form="postfix">∥</mo></mrow></mfrac><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><mi>h</mi><mo>&lt;</mo><mi>T</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\tilde\rho_h=\frac{1}{T}\sum_{i=1}^{T-h} \langle \frac{X_i - \tilde{\mu}}{\|X_i - \tilde{\mu}\|}, \frac{X_{i+h} - \tilde{\mu}}{\|X_{i+h} - \tilde{\mu}\|} \rangle,\ \ \ \ 0 \le h &lt; T,</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>μ</mi><mo accent="true">̃</mo></mover><annotation encoding="application/x-tex">\tilde{\mu}</annotation></semantics></math>
is the estimated spatial median of the series. The range of the measure
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>≤</mo><msub><mover><mi>ρ</mi><mo accent="true">̃</mo></mover><mi>h</mi></msub><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1 \le \tilde{\rho}_h \le 1</annotation></semantics></math>.
The fSACF provides advantages that the fACF does not: 1) it captures not
only the magnitude but also the direction of the serial correlation in
the series, 2) it is more robust against outliers. See the function
<code><a href="../reference/sacf.html">sacf()</a></code>.</p>
<p>First consider a Brownian motion that is known to have no signal as
given below.</p>
<div class="float">
<img src="functionaldata/bm_plot.png" style="width:5in" alt="Brownian Motion."><div class="figcaption"><strong><em>Brownian Motion.</em></strong></div>
</div>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span></span>
<span><span class="va">data_bm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/generate_brownian_motion.html">generate_brownian_motion</a></span><span class="op">(</span><span class="fl">150</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">data_bm</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/bm_acf.png" style="width:5in" alt="Autocorrelation via fACF of Brownian Motion."><div class="figcaption"><strong><em>Autocorrelation via fACF of Brownian
Motion.</em></strong></div>
</div>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/acf.html">acf</a></span><span class="op">(</span><span class="va">data_bm</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/bm_sacf.png" style="width:5in" alt="Autocorrelation via fSACF of Brownian Motion."><div class="figcaption"><strong><em>Autocorrelation via fSACF of
Brownian Motion.</em></strong></div>
</div>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">data_bm</span><span class="op">)</span></span></code></pre></div>
<p>The Spanish electricity data contains patterns that are reflected in
the fACF and fSACF plots given below. The differenced data, which
subtracted the previous days’ prices from current day, shows far less
signal but with noticeable spikes every 7 lags, suggesting there remains
weekly seasonality; see below.</p>
<div class="float">
<img src="functionaldata/electricity_acf.png" style="width:5in" alt="Autocorrelation in the electricity data as described by the fACF."><div class="figcaption"><strong><em>Autocorrelation in the electricity
data as described by the fACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/acf.html">acf</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_sacf.png" style="width:5in" alt="Autocorrelation in the electricity data as described by the fSACF."><div class="figcaption"><strong><em>Autocorrelation in the electricity
data as described by the fSACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_residuals_acf.png" style="width:5in" alt="Autocorrelation in the electricity data model residuals as described by the fACF."><div class="figcaption"><strong><em>Autocorrelation in the electricity
data model residuals as described by the fACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/acf.html">acf</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/acf.html">acf</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_residuals_sacf.png" style="width:5in" alt="Autocorrelation in the electricity data model residuals as described by the fSACF."><div class="figcaption"><strong><em>Autocorrelation in the electricity
data model residuals as described by the fSACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_diff_acf.png" style="width:5in" alt="Autocorrelation in the differenced electricity data as described by the fACF."><div class="figcaption"><strong><em>Autocorrelation in the differenced
electricity data as described by the fACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/acf.html">acf</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_diff_sacf.png" style="width:5in" alt="Autocorrelation in the differenced electricity data as described by the fSACF."><div class="figcaption"><strong><em>Autocorrelation in the differenced
electricity data as described by the fSACF.</em></strong></div>
</div>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="white-noise-tests">White noise tests<a class="anchor" aria-label="anchor" href="#white-noise-tests"></a>
</h3>
<p>If an FTS is a function valued white noise, or in other words is
comprised of independent and identically distributed curves, then we
expect to see
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ρ</mi><mo accent="true">̂</mo></mover><mi>h</mi></msub><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\hat{\rho}_h \approx 0</annotation></semantics></math>
all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>.
We often test whether a series appears to be a white noise by
aggregating the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ρ</mi><mo accent="true">̂</mo></mover><mi>h</mi></msub><annotation encoding="application/x-tex">\hat{\rho}_h</annotation></semantics></math>
or several values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>.
One example of such a test statistic is <span class="math display">$${\rm KRS}_{T,H} = T
\sum_{h=1}^H\|\hat\gamma_{T,h}\|^2,$$</span> which was introduced in
<span class="citation">(Kokoszka, Rice, and Shang 2017)</span> and
measures the serial covariance in the series aggregated up to a
user-specified maximum lag
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>.
A higher value of <span class="math inline">${\rm KRS}_{T,H}$</span>
suggests a potential departure of the observed series from a white noise
process. The approximate null distribution of this statistic has been
computed for FTS that are strong or weak white noise processes, which
facilitates the calculation of a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">p-</annotation></semantics></math>value
of such a white noise test.</p>
<p>Many similar white noise tests for FTS have been developed based on
other measures and aggregation principles, and a number of them are
implemented in the function <code><a href="../reference/portmanteau_tests.html">portmanteau_tests()</a></code>. The tests
below show non-significant values for the brownian motion and
significant for the electricity data.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/portmanteau_tests.html">portmanteau_tests</a></span><span class="op">(</span><span class="va">data_bm</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/portmanteau_tests.html">portmanteau_tests</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/portmanteau_tests.html">portmanteau_tests</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/portmanteau_tests.html">portmanteau_tests</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<p>The residuals of the electricity arima-based Hyndman-Ullah model and
the related fSACF are shown below. It appears that the majority of the
autocorrelation was captured with the model; however, the residuals
still do not be appear to be white noise per the portmanteau multi-lag
white noise tests’ p-values shown in Figure <a href="#fig:electricity_residuals_mlwn" reference-type="ref" reference="fig:electricity_residuals_mlwn">3.4</a>.</p>
<div class="float">
<img src="functionaldata/electricity_residuals.png" style="width:5in" alt="Residuals from the arima-based Hyndman-Ullah model."><div class="figcaption"><strong><em>Residuals from the arima-based
Hyndman-Ullah model.</em></strong></div>
</div>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/electricity_residuals_sacf.png" style="width:5in" alt="Autocorrelation of the residuals from the arima-based Hyndman-Ullah model."><div class="figcaption"><strong><em>Autocorrelation of the residuals
from the arima-based Hyndman-Ullah model.</em></strong></div>
</div>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/sacf.html">sacf</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<div class="float">
<img src="functionaldata/bm_mlwn.png" style="width:5in" alt="Multi-lag white noise portmanteau tests’ p-values for the Brownian motion. "><div class="figcaption"><strong><em>Multi-lag white noise portmanteau
tests’ p-values for the Brownian motion. </em></strong></div>
</div>
<div class="float" id="fig:electricity_residuals_mlwn">
<img src="functionaldata/electricity_residuals_mlwn.png" style="width:5in" alt="Multi-lag white noise portmanteau tests’ p-values for the residuals from the arima-based Hyndman-Ullah model (arima, ets is similar). "><div class="figcaption"><strong><em>Multi-lag white noise portmanteau
tests’ p-values for the residuals from the arima-based Hyndman-Ullah
model (arima, ets is similar). </em></strong></div>
</div>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lag.max</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">p_values_bm</span> <span class="op">&lt;-</span> <span class="va">p_values_ets</span> <span class="op">&lt;-</span> <span class="va">p_values_arima</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">lag.max</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">h1</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">lag.max</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">p_values_bm</span><span class="op">[</span><span class="va">h1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">.multi_lag_test</span><span class="op">(</span><span class="va">data_bm</span>, lag <span class="op">=</span> <span class="va">h1</span><span class="op">)</span><span class="op">$</span><span class="va">pvalue</span></span>
<span>  <span class="va">p_values_ets</span><span class="op">[</span><span class="va">h1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">.multi_lag_test</span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span>, lag <span class="op">=</span> <span class="va">h1</span><span class="op">)</span><span class="op">$</span><span class="va">pvalue</span></span>
<span>  <span class="va">p_values_arima</span><span class="op">[</span><span class="va">h1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">.multi_lag_test</span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span>, lag <span class="op">=</span> <span class="va">h1</span><span class="op">)</span><span class="op">$</span><span class="va">pvalue</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># bm wn test</span></span>
<span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">lag.max</span>, y <span class="op">=</span> <span class="va">p_values_bm</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html" class="external-link">geom_hline</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>    linetype <span class="op">=</span> <span class="st">"dotted"</span>,</span>
<span>    col <span class="op">=</span> <span class="st">"red"</span>, linewidth <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html" class="external-link">theme</a></span><span class="op">(</span>axis.text <span class="op">=</span> <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html" class="external-link">element_text</a></span><span class="op">(</span>size <span class="op">=</span> <span class="fl">18</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">xlab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ylab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/guides.html" class="external-link">guides</a></span><span class="op">(</span>color <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># ets residuals wn test</span></span>
<span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">lag.max</span>, y <span class="op">=</span> <span class="va">p_values_ets</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html" class="external-link">geom_hline</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>    linetype <span class="op">=</span> <span class="st">"dotted"</span>,</span>
<span>    col <span class="op">=</span> <span class="st">"red"</span>, linewidth <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html" class="external-link">theme</a></span><span class="op">(</span>axis.text <span class="op">=</span> <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html" class="external-link">element_text</a></span><span class="op">(</span>size <span class="op">=</span> <span class="fl">18</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">xlab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ylab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/guides.html" class="external-link">guides</a></span><span class="op">(</span>color <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># arima residuals wn test</span></span>
<span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">lag.max</span>, y <span class="op">=</span> <span class="va">p_values_arima</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html" class="external-link">geom_hline</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>    linetype <span class="op">=</span> <span class="st">"dotted"</span>,</span>
<span>    col <span class="op">=</span> <span class="st">"red"</span>, linewidth <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html" class="external-link">theme</a></span><span class="op">(</span>axis.text <span class="op">=</span> <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html" class="external-link">element_text</a></span><span class="op">(</span>size <span class="op">=</span> <span class="fl">18</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">xlab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">ylab</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/guides.html" class="external-link">guides</a></span><span class="op">(</span>color <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span></code></pre></div>
<p>See also the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code> function (plots suppressed).</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">bm_data</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="stationarity-and-change-point-testing">Stationarity and Change-Point Testing<a class="anchor" aria-label="anchor" href="#stationarity-and-change-point-testing"></a>
</h3>
<p>Since many procedures to analyze FTS assume at some level that the
data are stationary, it is useful to have methods to evaluate the
plausibility of that assumption. Moreover, in many cases evident
departures from stationarity appear to be due to shocks or “structural
changes" to the data generating mechanism. Such”change points" can be of
independent interest, or we might alter models that we use for FTS in
light of detecting and estimating the locations of such changes. The
methods used for this latter task fall under the umbrella of <em>change
point analysis</em>.</p>
<p>Test statistics for stationarity and change point detection often
rely on the functional partial sum process,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>S</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>T</mi></msqrt></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>T</mi><mi>x</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></munderover><msub><mi>X</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    S_T(x,t) = \frac{1}{\sqrt{T}} \sum_{i=1}^{\lfloor T x\rfloor} X_i(t)
\end{aligned}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\in[0,1]</annotation></semantics></math>
is termed the “partial sample parameter". Note that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mi>T</mi></msqrt><msub><mover><mi>X</mi><mo accent="true">‾</mo></mover><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">S_T(1,t) = \sqrt{T}\bar{X}_T</annotation></semantics></math>.
This can be used to define the cumulative sum (CUSUM) process
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Z</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>S</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>x</mi><msub><mi>S</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    Z_T(x, t) = S_T(x,t) - x S_T(1,t)\,.
\end{aligned}</annotation></semantics></math> When the data are
non-stationary, the CUSUM process tends to fluctuate more with respect
to the partial sample parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
than when the data are stationary. Natural test statistics based on the
CUSUM process that measure the magnitude of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>T</mi></msub><annotation encoding="application/x-tex">Z_{T}</annotation></semantics></math>
are</p>
<p><span class="math display">$$\begin{aligned}
    I_T = \int_0^1 \hspace{-.1cm} \int_0^1 Z_T^2(x,t) dt\,dx\, ,
\end{aligned}$$</span> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>M</mi><mi>T</mi></msub><mo>=</mo><munder><mo>sup</mo><mrow><mi>x</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow></munder><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msubsup><mi>Z</mi><mi>T</mi><mn>2</mn></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    M_T = \sup_{x \in [0,1]} \int_0^1 Z_T^2(x,t) dt.
\end{aligned}</annotation></semantics></math></p>
<p>Methods are proposed in <span class="citation">(Aue, Rice, and Sönmez
2018)</span> and <span class="citation">(Horváth, Kokoszka, and Rice
2014)</span> to produce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">p-</annotation></semantics></math>values
assessing the evidence against the hypothesis that the data are
stationary and that there are no change points present based on these
statistics.</p>
<p>One stationary test is implemented as <code>stationary_test()</code>.
The brownian motion has a non-significant p-value suggesting
stationarity for both tests. The Spanish electricity data has a p-value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>0.001</mn></mrow><annotation encoding="application/x-tex">&lt;0.001</annotation></semantics></math>
for the tests. The first difference and the model residuals both return
non-significant p-values, suggesting stationarity.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/stationarity_test.html">stationarity_test</a></span><span class="op">(</span><span class="va">data_bm</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/stationarity_test.html">stationarity_test</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/stationarity_test.html">stationarity_test</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/stationarity_test.html">stationarity_test</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/kpss_test.html">kpss_test</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/kpss_test.html">kpss_test</a></span><span class="op">(</span><span class="va">elec_ets</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/kpss_test.html">kpss_test</a></span><span class="op">(</span><span class="va">elec_arima</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">residuals</span><span class="op">)</span></span></code></pre></div>
<p>Applying change point detection on the electricity data, two change
point are observed; see Figures <a href="#fig:electricity_changes" reference-type="ref" reference="fig:electricity_changes">3.5</a> and<a href="#fig:electricity_changes_plot" reference-type="ref" reference="fig:electricity_changes_plot">3.6</a>.</p>
<div class="float" id="fig:electricity_changes">
<img src="functionaldata/electricity_changes.png" style="width:5in" alt="Changes in the distribution of the electricity data."><div class="figcaption"><strong><em>Changes in the distribution of the
electricity data.</em></strong></div>
</div>
<div class="float" id="fig:electricity_changes_plot">
<img src="functionaldata/electricity_changes_plot.png" style="width:5in" alt="Changes in the distribution of the electricity data, highlighting mean of the segments."><div class="figcaption"><strong><em>Changes in the distribution of the
electricity data, highlighting mean of the segments.</em></strong></div>
</div>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span></span>
<span><span class="va">elec_changes</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fchange.html">fchange</a></span><span class="op">(</span><span class="va">electricity</span>, type <span class="op">=</span> <span class="st">"segmentation"</span><span class="op">)</span></span>
<span><span class="va">elec_changes</span><span class="op">$</span><span class="va">location</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">electricity</span>,</span>
<span>  changes <span class="op">=</span> <span class="va">elec_changes</span><span class="op">$</span><span class="va">location</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">0.8</span>, y <span class="op">=</span> <span class="fl">0.6</span>, z <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">electricity</span>,</span>
<span>  changes <span class="op">=</span> <span class="va">elec_changes</span><span class="op">$</span><span class="va">location</span>, type <span class="op">=</span> <span class="st">"change"</span>,</span>
<span>  plot_title <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  eye <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, z <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span>,</span>
<span>  aspectratio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">0.8</span>, y <span class="op">=</span> <span class="fl">0.6</span>, z <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Since changes suggest regions of homogeneity in the data, CV was
re-run looking at 14 day forecasts in order to compare the previous
models to models based on only the last homogeneous segment: 1.000
(ets), 1.013 (arima), 1.157 (ets with cp), and 1.232 (arima with cp).
Although the data in the last segment appears to be more homogeneous, in
this case the reduction of data lead to worse CV performance. Try
another segmentation and see if it has a different effect!</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># CV</span></span>
<span><span class="va">pred_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor</a></span><span class="op">(</span><span class="fl">0.8</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">electricity</span><span class="op">)</span> <span class="op">-</span> <span class="fl">13</span><span class="op">)</span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"fets"</span>, <span class="st">"farima"</span>, <span class="st">"fetsC"</span>, <span class="st">"farimaC"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">cp</span> <span class="op">&lt;-</span> <span class="fl">120</span> <span class="co"># max(elec_changes$location)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"CV ("</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span>, <span class="st">"):"</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pred_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">i</span>, <span class="st">", "</span><span class="op">)</span></span>
<span>  <span class="va">idx</span> <span class="op">&lt;-</span> <span class="va">pred_idx</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">idx</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span>  <span class="va">tmp_dat1</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span>, <span class="va">cp</span><span class="op">:</span><span class="op">(</span><span class="va">idx</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="va">tmp_dat1</span><span class="op">$</span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fl">7</span></span>
<span>  <span class="va">tmp_pred</span> <span class="op">&lt;-</span> <span class="va">electricity</span><span class="op">[</span><span class="va">idx</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span></span>
<span>  <span class="va">pm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">14</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">14</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat1</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"ets"</span>, n.ahead <span class="op">=</span> <span class="fl">14</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">pm4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">tmp_dat1</span>,</span>
<span>    forecast.model <span class="op">=</span> <span class="st">"arima"</span>, n.ahead <span class="op">=</span> <span class="fl">14</span>,</span>
<span>    check.cp <span class="op">=</span> <span class="cn">F</span>, sim.bounds <span class="op">=</span> <span class="cn">F</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    <span class="st">"fets"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm1</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farima"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm2</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"fetsC"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm3</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span> <span class="op">-</span> <span class="va">cp</span> <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span>    <span class="op">)</span>,</span>
<span>    <span class="st">"farimaC"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>      <span class="va">pm4</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">component_true</span><span class="op">$</span><span class="va">data</span><span class="op">[</span>, <span class="va">idx</span> <span class="op">-</span> <span class="va">cp</span> <span class="op">+</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="op">(</span><span class="va">ests</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">tmp_pred</span><span class="op">$</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#   fets   farima  fetsC  farimaC</span></span>
<span><span class="co">#   1.000  1.013   1.157  1.232</span></span></code></pre></div>
<p>For the French mortality, an example segmentation and forecast is
given below.</p>
<div class="float">
<img src="functionaldata/fmort_change_for.png" style="width:5in" alt="Change and forecast for the French mortality."><div class="figcaption"><strong><em>Change and forecast for the French
mortality.</em></strong></div>
</div>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/projection_model.html">projection_model</a></span><span class="op">(</span><span class="va">fmort</span>, sim.bounds <span class="op">=</span> <span class="cn">FALSE</span>, method <span class="op">=</span> <span class="st">"eigenjoint"</span>, n.ahead <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">tmp</span><span class="op">$</span><span class="va">plots</span><span class="op">$</span><span class="va">forecast_plot</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="exercises-2">Exercises<a class="anchor" aria-label="anchor" href="#exercises-2"></a>
</h3>
<p>The data for these exercises can be downloaded as given at the start
of this document. These data comprise electricity spot prices in
Germany:</p>
<ol style="list-style-type: decimal">
<li><p>Apply an autocorrelation analysis to the German electricity price
data. Apply a similar analysis to the residuals of a forecasting model
for such data, and comment on whether the model appears to be fitting
well.</p></li>
<li><p>Apply a white noise test to the model residuals of a forecasting
model of the German electricity prices.</p></li>
<li><p>Apply a stationarity test to the German electricity data and to
its model residuals.</p></li>
<li><p>Using what you have learned so far, come up with the best
forecast that you can for the German electricity price data 2 weeks
ahead. Let the instructor know when you have completed this.</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-aue:rice:sonmez:2018" class="csl-entry">
Aue, A., G. Rice, and O. Sönmez. 2018. <span>“Detecting and Dating
Structural Breaks in Functional Data Without Dimension
Reduction.”</span> <em>Journal of the Royal Statistical Society, Series
B</em> 80: 509–29.
</div>
<div id="ref-box:jenkins:1970" class="csl-entry">
Box, G. E. P., and G. M. Jenkins. 1970. <em>Time Series Analysis;
Forecasting and Control</em>. New York: Holden Day.
</div>
<div id="ref-horvath:kokoszka:rice:2014" class="csl-entry">
Horváth, L., P. Kokoszka, and G. Rice. 2014. <span>“Testing Stationarity
of Functional Time Series.”</span> <em>Journal of Econometrics</em> 179:
66–82.
</div>
<div id="ref-hyndman:khandakar:2008" class="csl-entry">
Hyndman, Rob J, and Yeasmin Khandakar. 2008. <span>“Automatic Time
Series Forecasting: The Forecast Package for <span>R</span>.”</span>
<em>Journal of Statistical Software</em> 26 (3): 1–22. <a href="https://doi.org/10.18637/jss.v027.i03" class="external-link">https://doi.org/10.18637/jss.v027.i03</a>.
</div>
<div id="ref-hyndman:ullah:2007:forecast" class="csl-entry">
Hyndman, Rob J, and Md Shahid Ullah. 2007. <span>“Robust Forecasting of
Mortality and Fertility Rates: A Functional Data Approach.”</span>
<em>Computational Statistics &amp; Data Analysis</em> 51: 4942–56.
</div>
<div id="ref-kokoszka:rice:shang:2017" class="csl-entry">
Kokoszka, P., G. Rice, and H. L. Shang. 2017. <span>“Inference for the
Autocovariance of a Functional Time Series Under Conditional
Heteroscedasticity.”</span> <em>Journal of Multivariate Analysis</em>
162: 32–50.
</div>
<div id="ref-KPSS:1992" class="csl-entry">
Kwiatkowski, D., P. C. B. Phillips, P. Schmidt, and Y. Shin. 1992.
<span>“Testing the Null Hypothesis of Stationarity Against the
Alternative of a Unit Root: How Sure Are We That Economic Time Series
Have a Unit Root?”</span> <em>Journal of Econometrics</em> 54: 159–78.
</div>
<div id="ref-ramsay:silverman:2005" class="csl-entry">
Ramsay, J. O., and B. W. Silverman. 2005. <em>Functional
<span>D</span>ata <span>A</span>nalysis</em>. Springer.
</div>
<div id="ref-ramsay:hooker:graves:2009" class="csl-entry">
Ramsay, J., G. Hooker, and S. Graves. 2009. <em>Functional
<span>D</span>ata <span>A</span>nalysis with <span>R</span> and
<span>MATLAB</span></em>. Springer.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jeremy VanderDoes, Gregory Rice, Martin Wendler.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
