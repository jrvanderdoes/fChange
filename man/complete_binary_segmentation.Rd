% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/binary_segmentation.R
\name{complete_binary_segmentation}
\alias{complete_binary_segmentation}
\title{Complete Binary Segmentation}
\usage{
complete_binary_segmentation(
  data,
  test_statistic_function,
  cutoff_function,
  trim_function,
  alpha = 0.05,
  final_verify = T,
  silent = F,
  ...
)
}
\arguments{
\item{data}{Numeric data.frame with rows for evaluated values and columns
indicating FD}

\item{test_statistic_function}{Function with the first argument being data
and the second argument optional argument for candidate change points.
Additional arguments passed in via ... . Return a single numeric value.}

\item{cutoff_function}{Function with first argument being data and the second
argument being alpha. No other arguments given. Return single numeric
value.}

\item{trim_function}{Function taking data as an argument and returning a
numeric value indicating how much should be trimmed on each end}

\item{alpha}{Numeric value in \link{0,1} indicating the significance for
cutoff_function.}

\item{final_verify}{(Optional) Boolean value

Indicates if a final pass looking at sequences with only one change point
should be conducted to verify results. Note, this may modify existing
locations of change points, potentially to less accurate locations.}

\item{silent}{(Optional) Boolean value

Indicates if useful output should be silenced. Default F shows output.}

\item{...}{Additional arguments passed into test_statistic_function}
}
\value{
A list of numeric values indicating change points  (if exists),
NA otherwise
}
\description{
This function implements traditional binary segmentation on functional data
for general functions. Change points are recursively found until no
more change points are detected.
}
\examples{
# Setup Data
data_KL <- generate_data_fd(ns = c(200),
    eigsList = list(c(3,2,1,0.5)),
    basesList = list(fda::create.bspline.basis(nbasis=4, norder=4)),
    meansList = c(0),
    distsArray = c('Normal'),
    evals = seq(0,1,0.05),
    kappasArray = c(0))
complete_binary_segmentation(data_KL, compute_Tn, welsh_approximation,
    function(data){floor(log(ncol(data)))})
# Setup Data
data_KL <- generate_data_fd(ns = c(100,100),
    eigsList = list(c(3,2,1,0.5),
                    c(3,2,1,0.5)),
    basesList = list(fda::create.bspline.basis(nbasis=4, norder=4),
                     fda::create.bspline.basis(nbasis=4, norder=4)),
    meansList = c(-1,1),
    distsArray = c('Normal','Normal'),
    evals = seq(0,1,0.05),
    kappasArray = c(0,0))
complete_binary_segmentation(data_KL, compute_Tn, welsh_approximation,
    function(data){floor(log(ncol(data)))})

# Setup Data
data_KL <- generate_data_fd(ns = c(100,100,100),
    eigsList = list(c(3,2,1,0.5),
                    c(3,2,1,0.5),
                    c(3,2)),
    basesList = list(fda::create.bspline.basis(nbasis=4, norder=4),
                     fda::create.bspline.basis(nbasis=4, norder=4),
                     fda::create.bspline.basis(nbasis=2, norder=2)),
    meansList = c(-1,1,1),
    distsArray = c('Normal','Normal','Normal'),
    evals = seq(0,1,0.05),
    kappasArray = c(0,0,0))
complete_binary_segmentation(data_KL, compute_Tn, welsh_approximation,
    function(data){floor(log(ncol(data)))})
}
