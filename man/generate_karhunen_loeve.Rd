% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_data_kl.R
\name{generate_karhunen_loeve}
\alias{generate_karhunen_loeve}
\title{Generate functional data}
\usage{
generate_karhunen_loeve(
  N,
  eigenvalues,
  basis,
  means,
  distribution,
  resolution,
  dependence = 0,
  burnin = 100,
  silent = TRUE,
  dof = NULL,
  shape = NULL,
  prev_eps = NULL
)
}
\arguments{
\item{N}{Vector of Numerics. Each value in N is the number of observations
for a given group.}

\item{eigenvalues}{Vector of eigenvalues. Length 1 or m.}

\item{basis}{A list of bases (eigenfunctions), length m.}

\item{means}{A vector of means, length 1 or N.}

\item{distribution}{A vector of distributions, length 1 or m.}

\item{resolution}{A vector of points indicating the points to evaluate the
functions on.}

\item{dependence}{Numeric [0,1] indicating strength of VAR(1) process.}

\item{burnin}{A numeric value indicating the number of burnin trials.}

\item{silent}{A Boolean that toggles running output.}

\item{dof}{Numeric for degrees of freedom with t-distribution}

\item{prev_eps}{previous epsilon for dependence across groups.}
}
\value{
List with (1) data (N-by-m) and (2) previous errors.
}
\description{
\code{generate_karhunen_loeve} generates functional data via KL expansion.
This can include change points in any combination of the following:
\itemize{
\item Mean
\item Distribution
\item Eigenvalue(s)
\item Eigenvector(s)
}
In this sense, the function creates m 'groups' of discretely observed
functions with similar properties.
}
\examples{
# result <- generate_karhunen_loeve(
#   N=c(100,50,25),
#   eigenvalues = list(rep(1,5),
#                      c(1/sqrt(1:5)),
#                      c(1/sqrt(1:5))),
#
#   parameters =list('bmotion'=list('N'=100, 'process'='bmotion', 'sd'=1),
#                    'bbridge'=list('N'=100, 'process'='bbridge', 'sd'=1),
#                    'kl'=list('process'='kl', 'N'=100,
#                              'distribution'='Normal',
#                              'eigenvalues'=1/1:4,
#                              'mean'=0, 'dependence'=0,
#                              'basis'=fda::create.bspline.basis(),
#                              'sd'=1),
#                    'ou'=list('N'=100, 'process'='ou', 'dependence'=0 ) ,
#                    'far1'=list('N'=100, 'process'='far1', 'dependence'=0,
#                                'sd'=1,'vary'=FALSE) )
#                  )
}
